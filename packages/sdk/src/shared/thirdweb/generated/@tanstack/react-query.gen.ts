// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getV1Webhooks, postV1Webhooks, deleteV1WebhooksByWebhookId, patchV1WebhooksByWebhookId, postV1WebhooksTest, getV1Events, getV1EventsByContractAddress, getV1EventsByContractAddressBySignature, getV1Transactions, getV1TransactionsByContractAddress, getV1TransactionsByContractAddressBySignature, getV1TokensTransfersTransactionByTransactionHash, getV1TokensTransfersByContractAddress, getV1TokensTransfers, getV1TokensErc20ByOwnerAddress, getV1TokensErc721ByOwnerAddress, getV1TokensErc1155ByOwnerAddress, getV1TokensPriceSupported, getV1TokensPrice, getV1TokensLookup, getV1ResolveByInput, getV1Blocks, getV1ContractsAbiByContractAddress, getV1ContractsMetadataByContractAddress, postV1DecodeByContractAddress, getV1NftsBalanceByOwnerAddress, getV1NftsCollectionsByContractAddress, getV1Nfts, getV1NftsOwnersByContractAddress, getV1NftsOwnersByContractAddressByTokenId, getV1NftsTransfers, getV1NftsTransfersTransactionByTransactionHash, getV1NftsTransfersByContractAddress, getV1NftsByContractAddress, getV1NftsTransfersByContractAddressByTokenId, getV1NftsByContractAddressByTokenId, getV1NftsMetadataRefreshByContractAddress, getV1NftsMetadataRefreshByContractAddressByTokenId, getV1WalletsByWalletAddressTransactions } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, infiniteQueryOptions, type InfiniteData, type DefaultError } from '@tanstack/react-query';
import type { GetV1WebhooksData, PostV1WebhooksData, PostV1WebhooksError, PostV1WebhooksResponse, DeleteV1WebhooksByWebhookIdData, DeleteV1WebhooksByWebhookIdError, DeleteV1WebhooksByWebhookIdResponse, PatchV1WebhooksByWebhookIdData, PatchV1WebhooksByWebhookIdError, PatchV1WebhooksByWebhookIdResponse, PostV1WebhooksTestData, PostV1WebhooksTestError, PostV1WebhooksTestResponse, GetV1EventsData, GetV1EventsError, GetV1EventsResponse, GetV1EventsByContractAddressData, GetV1EventsByContractAddressError, GetV1EventsByContractAddressResponse, GetV1EventsByContractAddressBySignatureData, GetV1EventsByContractAddressBySignatureError, GetV1EventsByContractAddressBySignatureResponse, GetV1TransactionsData, GetV1TransactionsError, GetV1TransactionsResponse, GetV1TransactionsByContractAddressData, GetV1TransactionsByContractAddressError, GetV1TransactionsByContractAddressResponse, GetV1TransactionsByContractAddressBySignatureData, GetV1TransactionsByContractAddressBySignatureError, GetV1TransactionsByContractAddressBySignatureResponse, GetV1TokensTransfersTransactionByTransactionHashData, GetV1TokensTransfersTransactionByTransactionHashError, GetV1TokensTransfersTransactionByTransactionHashResponse, GetV1TokensTransfersByContractAddressData, GetV1TokensTransfersByContractAddressError, GetV1TokensTransfersByContractAddressResponse, GetV1TokensTransfersData, GetV1TokensTransfersError, GetV1TokensTransfersResponse, GetV1TokensErc20ByOwnerAddressData, GetV1TokensErc20ByOwnerAddressResponse, GetV1TokensErc721ByOwnerAddressData, GetV1TokensErc721ByOwnerAddressResponse, GetV1TokensErc1155ByOwnerAddressData, GetV1TokensErc1155ByOwnerAddressResponse, GetV1TokensPriceSupportedData, GetV1TokensPriceData, GetV1TokensLookupData, GetV1ResolveByInputData, GetV1BlocksData, GetV1BlocksError, GetV1BlocksResponse, GetV1ContractsAbiByContractAddressData, GetV1ContractsMetadataByContractAddressData, PostV1DecodeByContractAddressData, PostV1DecodeByContractAddressError, PostV1DecodeByContractAddressResponse, GetV1NftsBalanceByOwnerAddressData, GetV1NftsBalanceByOwnerAddressResponse, GetV1NftsCollectionsByContractAddressData, GetV1NftsData, GetV1NftsError, GetV1NftsResponse, GetV1NftsOwnersByContractAddressData, GetV1NftsOwnersByContractAddressError, GetV1NftsOwnersByContractAddressResponse, GetV1NftsOwnersByContractAddressByTokenIdData, GetV1NftsOwnersByContractAddressByTokenIdError, GetV1NftsOwnersByContractAddressByTokenIdResponse, GetV1NftsTransfersData, GetV1NftsTransfersError, GetV1NftsTransfersResponse, GetV1NftsTransfersTransactionByTransactionHashData, GetV1NftsTransfersTransactionByTransactionHashError, GetV1NftsTransfersTransactionByTransactionHashResponse, GetV1NftsTransfersByContractAddressData, GetV1NftsTransfersByContractAddressError, GetV1NftsTransfersByContractAddressResponse, GetV1NftsByContractAddressData, GetV1NftsByContractAddressError, GetV1NftsByContractAddressResponse, GetV1NftsTransfersByContractAddressByTokenIdData, GetV1NftsTransfersByContractAddressByTokenIdError, GetV1NftsTransfersByContractAddressByTokenIdResponse, GetV1NftsByContractAddressByTokenIdData, GetV1NftsMetadataRefreshByContractAddressData, GetV1NftsMetadataRefreshByContractAddressByTokenIdData, GetV1WalletsByWalletAddressTransactionsData, GetV1WalletsByWalletAddressTransactionsError, GetV1WalletsByWalletAddressTransactionsResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getV1WebhooksQueryKey = (options?: Options<GetV1WebhooksData>) => createQueryKey('getV1Webhooks', options);

export const getV1WebhooksOptions = (options?: Options<GetV1WebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1Webhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1WebhooksQueryKey(options)
    });
};

export const postV1WebhooksQueryKey = (options?: Options<PostV1WebhooksData>) => createQueryKey('postV1Webhooks', options);

export const postV1WebhooksOptions = (options?: Options<PostV1WebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postV1Webhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postV1WebhooksQueryKey(options)
    });
};

export const postV1WebhooksMutation = (options?: Partial<Options<PostV1WebhooksData>>): UseMutationOptions<PostV1WebhooksResponse, PostV1WebhooksError, Options<PostV1WebhooksData>> => {
    const mutationOptions: UseMutationOptions<PostV1WebhooksResponse, PostV1WebhooksError, Options<PostV1WebhooksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postV1Webhooks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteV1WebhooksByWebhookIdMutation = (options?: Partial<Options<DeleteV1WebhooksByWebhookIdData>>): UseMutationOptions<DeleteV1WebhooksByWebhookIdResponse, DeleteV1WebhooksByWebhookIdError, Options<DeleteV1WebhooksByWebhookIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteV1WebhooksByWebhookIdResponse, DeleteV1WebhooksByWebhookIdError, Options<DeleteV1WebhooksByWebhookIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteV1WebhooksByWebhookId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patchV1WebhooksByWebhookIdMutation = (options?: Partial<Options<PatchV1WebhooksByWebhookIdData>>): UseMutationOptions<PatchV1WebhooksByWebhookIdResponse, PatchV1WebhooksByWebhookIdError, Options<PatchV1WebhooksByWebhookIdData>> => {
    const mutationOptions: UseMutationOptions<PatchV1WebhooksByWebhookIdResponse, PatchV1WebhooksByWebhookIdError, Options<PatchV1WebhooksByWebhookIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patchV1WebhooksByWebhookId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postV1WebhooksTestQueryKey = (options?: Options<PostV1WebhooksTestData>) => createQueryKey('postV1WebhooksTest', options);

export const postV1WebhooksTestOptions = (options?: Options<PostV1WebhooksTestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postV1WebhooksTest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postV1WebhooksTestQueryKey(options)
    });
};

export const postV1WebhooksTestMutation = (options?: Partial<Options<PostV1WebhooksTestData>>): UseMutationOptions<PostV1WebhooksTestResponse, PostV1WebhooksTestError, Options<PostV1WebhooksTestData>> => {
    const mutationOptions: UseMutationOptions<PostV1WebhooksTestResponse, PostV1WebhooksTestError, Options<PostV1WebhooksTestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postV1WebhooksTest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getV1EventsQueryKey = (options?: Options<GetV1EventsData>) => createQueryKey('getV1Events', options);

export const getV1EventsOptions = (options?: Options<GetV1EventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1Events({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1EventsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getV1EventsInfiniteQueryKey = (options?: Options<GetV1EventsData>): QueryKey<Options<GetV1EventsData>> => createQueryKey('getV1Events', options, true);

export const getV1EventsInfiniteOptions = (options?: Options<GetV1EventsData>) => {
    return infiniteQueryOptions<GetV1EventsResponse, GetV1EventsError, InfiniteData<GetV1EventsResponse>, QueryKey<Options<GetV1EventsData>>, number | null | Pick<QueryKey<Options<GetV1EventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1EventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1Events({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1EventsInfiniteQueryKey(options)
    });
};

export const getV1EventsByContractAddressQueryKey = (options: Options<GetV1EventsByContractAddressData>) => createQueryKey('getV1EventsByContractAddress', options);

export const getV1EventsByContractAddressOptions = (options: Options<GetV1EventsByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1EventsByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1EventsByContractAddressQueryKey(options)
    });
};

export const getV1EventsByContractAddressInfiniteQueryKey = (options: Options<GetV1EventsByContractAddressData>): QueryKey<Options<GetV1EventsByContractAddressData>> => createQueryKey('getV1EventsByContractAddress', options, true);

export const getV1EventsByContractAddressInfiniteOptions = (options: Options<GetV1EventsByContractAddressData>) => {
    return infiniteQueryOptions<GetV1EventsByContractAddressResponse, GetV1EventsByContractAddressError, InfiniteData<GetV1EventsByContractAddressResponse>, QueryKey<Options<GetV1EventsByContractAddressData>>, number | null | Pick<QueryKey<Options<GetV1EventsByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1EventsByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1EventsByContractAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1EventsByContractAddressInfiniteQueryKey(options)
    });
};

export const getV1EventsByContractAddressBySignatureQueryKey = (options: Options<GetV1EventsByContractAddressBySignatureData>) => createQueryKey('getV1EventsByContractAddressBySignature', options);

export const getV1EventsByContractAddressBySignatureOptions = (options: Options<GetV1EventsByContractAddressBySignatureData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1EventsByContractAddressBySignature({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1EventsByContractAddressBySignatureQueryKey(options)
    });
};

export const getV1EventsByContractAddressBySignatureInfiniteQueryKey = (options: Options<GetV1EventsByContractAddressBySignatureData>): QueryKey<Options<GetV1EventsByContractAddressBySignatureData>> => createQueryKey('getV1EventsByContractAddressBySignature', options, true);

export const getV1EventsByContractAddressBySignatureInfiniteOptions = (options: Options<GetV1EventsByContractAddressBySignatureData>) => {
    return infiniteQueryOptions<GetV1EventsByContractAddressBySignatureResponse, GetV1EventsByContractAddressBySignatureError, InfiniteData<GetV1EventsByContractAddressBySignatureResponse>, QueryKey<Options<GetV1EventsByContractAddressBySignatureData>>, number | null | Pick<QueryKey<Options<GetV1EventsByContractAddressBySignatureData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1EventsByContractAddressBySignatureData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1EventsByContractAddressBySignature({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1EventsByContractAddressBySignatureInfiniteQueryKey(options)
    });
};

export const getV1TransactionsQueryKey = (options?: Options<GetV1TransactionsData>) => createQueryKey('getV1Transactions', options);

export const getV1TransactionsOptions = (options?: Options<GetV1TransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1Transactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TransactionsQueryKey(options)
    });
};

export const getV1TransactionsInfiniteQueryKey = (options?: Options<GetV1TransactionsData>): QueryKey<Options<GetV1TransactionsData>> => createQueryKey('getV1Transactions', options, true);

export const getV1TransactionsInfiniteOptions = (options?: Options<GetV1TransactionsData>) => {
    return infiniteQueryOptions<GetV1TransactionsResponse, GetV1TransactionsError, InfiniteData<GetV1TransactionsResponse>, QueryKey<Options<GetV1TransactionsData>>, number | null | Pick<QueryKey<Options<GetV1TransactionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TransactionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1Transactions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TransactionsInfiniteQueryKey(options)
    });
};

export const getV1TransactionsByContractAddressQueryKey = (options: Options<GetV1TransactionsByContractAddressData>) => createQueryKey('getV1TransactionsByContractAddress', options);

export const getV1TransactionsByContractAddressOptions = (options: Options<GetV1TransactionsByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TransactionsByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TransactionsByContractAddressQueryKey(options)
    });
};

export const getV1TransactionsByContractAddressInfiniteQueryKey = (options: Options<GetV1TransactionsByContractAddressData>): QueryKey<Options<GetV1TransactionsByContractAddressData>> => createQueryKey('getV1TransactionsByContractAddress', options, true);

export const getV1TransactionsByContractAddressInfiniteOptions = (options: Options<GetV1TransactionsByContractAddressData>) => {
    return infiniteQueryOptions<GetV1TransactionsByContractAddressResponse, GetV1TransactionsByContractAddressError, InfiniteData<GetV1TransactionsByContractAddressResponse>, QueryKey<Options<GetV1TransactionsByContractAddressData>>, number | null | Pick<QueryKey<Options<GetV1TransactionsByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TransactionsByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TransactionsByContractAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TransactionsByContractAddressInfiniteQueryKey(options)
    });
};

export const getV1TransactionsByContractAddressBySignatureQueryKey = (options: Options<GetV1TransactionsByContractAddressBySignatureData>) => createQueryKey('getV1TransactionsByContractAddressBySignature', options);

export const getV1TransactionsByContractAddressBySignatureOptions = (options: Options<GetV1TransactionsByContractAddressBySignatureData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TransactionsByContractAddressBySignature({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TransactionsByContractAddressBySignatureQueryKey(options)
    });
};

export const getV1TransactionsByContractAddressBySignatureInfiniteQueryKey = (options: Options<GetV1TransactionsByContractAddressBySignatureData>): QueryKey<Options<GetV1TransactionsByContractAddressBySignatureData>> => createQueryKey('getV1TransactionsByContractAddressBySignature', options, true);

export const getV1TransactionsByContractAddressBySignatureInfiniteOptions = (options: Options<GetV1TransactionsByContractAddressBySignatureData>) => {
    return infiniteQueryOptions<GetV1TransactionsByContractAddressBySignatureResponse, GetV1TransactionsByContractAddressBySignatureError, InfiniteData<GetV1TransactionsByContractAddressBySignatureResponse>, QueryKey<Options<GetV1TransactionsByContractAddressBySignatureData>>, number | null | Pick<QueryKey<Options<GetV1TransactionsByContractAddressBySignatureData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TransactionsByContractAddressBySignatureData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TransactionsByContractAddressBySignature({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TransactionsByContractAddressBySignatureInfiniteQueryKey(options)
    });
};

export const getV1TokensTransfersTransactionByTransactionHashQueryKey = (options: Options<GetV1TokensTransfersTransactionByTransactionHashData>) => createQueryKey('getV1TokensTransfersTransactionByTransactionHash', options);

export const getV1TokensTransfersTransactionByTransactionHashOptions = (options: Options<GetV1TokensTransfersTransactionByTransactionHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensTransfersTransactionByTransactionHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensTransfersTransactionByTransactionHashQueryKey(options)
    });
};

export const getV1TokensTransfersTransactionByTransactionHashInfiniteQueryKey = (options: Options<GetV1TokensTransfersTransactionByTransactionHashData>): QueryKey<Options<GetV1TokensTransfersTransactionByTransactionHashData>> => createQueryKey('getV1TokensTransfersTransactionByTransactionHash', options, true);

export const getV1TokensTransfersTransactionByTransactionHashInfiniteOptions = (options: Options<GetV1TokensTransfersTransactionByTransactionHashData>) => {
    return infiniteQueryOptions<GetV1TokensTransfersTransactionByTransactionHashResponse, GetV1TokensTransfersTransactionByTransactionHashError, InfiniteData<GetV1TokensTransfersTransactionByTransactionHashResponse>, QueryKey<Options<GetV1TokensTransfersTransactionByTransactionHashData>>, number | null | Pick<QueryKey<Options<GetV1TokensTransfersTransactionByTransactionHashData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TokensTransfersTransactionByTransactionHashData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TokensTransfersTransactionByTransactionHash({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensTransfersTransactionByTransactionHashInfiniteQueryKey(options)
    });
};

export const getV1TokensTransfersByContractAddressQueryKey = (options: Options<GetV1TokensTransfersByContractAddressData>) => createQueryKey('getV1TokensTransfersByContractAddress', options);

export const getV1TokensTransfersByContractAddressOptions = (options: Options<GetV1TokensTransfersByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensTransfersByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensTransfersByContractAddressQueryKey(options)
    });
};

export const getV1TokensTransfersByContractAddressInfiniteQueryKey = (options: Options<GetV1TokensTransfersByContractAddressData>): QueryKey<Options<GetV1TokensTransfersByContractAddressData>> => createQueryKey('getV1TokensTransfersByContractAddress', options, true);

export const getV1TokensTransfersByContractAddressInfiniteOptions = (options: Options<GetV1TokensTransfersByContractAddressData>) => {
    return infiniteQueryOptions<GetV1TokensTransfersByContractAddressResponse, GetV1TokensTransfersByContractAddressError, InfiniteData<GetV1TokensTransfersByContractAddressResponse>, QueryKey<Options<GetV1TokensTransfersByContractAddressData>>, number | null | Pick<QueryKey<Options<GetV1TokensTransfersByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TokensTransfersByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TokensTransfersByContractAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensTransfersByContractAddressInfiniteQueryKey(options)
    });
};

export const getV1TokensTransfersQueryKey = (options?: Options<GetV1TokensTransfersData>) => createQueryKey('getV1TokensTransfers', options);

export const getV1TokensTransfersOptions = (options?: Options<GetV1TokensTransfersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensTransfers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensTransfersQueryKey(options)
    });
};

export const getV1TokensTransfersInfiniteQueryKey = (options?: Options<GetV1TokensTransfersData>): QueryKey<Options<GetV1TokensTransfersData>> => createQueryKey('getV1TokensTransfers', options, true);

export const getV1TokensTransfersInfiniteOptions = (options?: Options<GetV1TokensTransfersData>) => {
    return infiniteQueryOptions<GetV1TokensTransfersResponse, GetV1TokensTransfersError, InfiniteData<GetV1TokensTransfersResponse>, QueryKey<Options<GetV1TokensTransfersData>>, number | null | Pick<QueryKey<Options<GetV1TokensTransfersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TokensTransfersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TokensTransfers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensTransfersInfiniteQueryKey(options)
    });
};

export const getV1TokensErc20ByOwnerAddressQueryKey = (options: Options<GetV1TokensErc20ByOwnerAddressData>) => createQueryKey('getV1TokensErc20ByOwnerAddress', options);

export const getV1TokensErc20ByOwnerAddressOptions = (options: Options<GetV1TokensErc20ByOwnerAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensErc20ByOwnerAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensErc20ByOwnerAddressQueryKey(options)
    });
};

export const getV1TokensErc20ByOwnerAddressInfiniteQueryKey = (options: Options<GetV1TokensErc20ByOwnerAddressData>): QueryKey<Options<GetV1TokensErc20ByOwnerAddressData>> => createQueryKey('getV1TokensErc20ByOwnerAddress', options, true);

export const getV1TokensErc20ByOwnerAddressInfiniteOptions = (options: Options<GetV1TokensErc20ByOwnerAddressData>) => {
    return infiniteQueryOptions<GetV1TokensErc20ByOwnerAddressResponse, DefaultError, InfiniteData<GetV1TokensErc20ByOwnerAddressResponse>, QueryKey<Options<GetV1TokensErc20ByOwnerAddressData>>, number | null | Pick<QueryKey<Options<GetV1TokensErc20ByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TokensErc20ByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TokensErc20ByOwnerAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensErc20ByOwnerAddressInfiniteQueryKey(options)
    });
};

export const getV1TokensErc721ByOwnerAddressQueryKey = (options: Options<GetV1TokensErc721ByOwnerAddressData>) => createQueryKey('getV1TokensErc721ByOwnerAddress', options);

export const getV1TokensErc721ByOwnerAddressOptions = (options: Options<GetV1TokensErc721ByOwnerAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensErc721ByOwnerAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensErc721ByOwnerAddressQueryKey(options)
    });
};

export const getV1TokensErc721ByOwnerAddressInfiniteQueryKey = (options: Options<GetV1TokensErc721ByOwnerAddressData>): QueryKey<Options<GetV1TokensErc721ByOwnerAddressData>> => createQueryKey('getV1TokensErc721ByOwnerAddress', options, true);

export const getV1TokensErc721ByOwnerAddressInfiniteOptions = (options: Options<GetV1TokensErc721ByOwnerAddressData>) => {
    return infiniteQueryOptions<GetV1TokensErc721ByOwnerAddressResponse, DefaultError, InfiniteData<GetV1TokensErc721ByOwnerAddressResponse>, QueryKey<Options<GetV1TokensErc721ByOwnerAddressData>>, number | null | Pick<QueryKey<Options<GetV1TokensErc721ByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TokensErc721ByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TokensErc721ByOwnerAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensErc721ByOwnerAddressInfiniteQueryKey(options)
    });
};

export const getV1TokensErc1155ByOwnerAddressQueryKey = (options: Options<GetV1TokensErc1155ByOwnerAddressData>) => createQueryKey('getV1TokensErc1155ByOwnerAddress', options);

export const getV1TokensErc1155ByOwnerAddressOptions = (options: Options<GetV1TokensErc1155ByOwnerAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensErc1155ByOwnerAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensErc1155ByOwnerAddressQueryKey(options)
    });
};

export const getV1TokensErc1155ByOwnerAddressInfiniteQueryKey = (options: Options<GetV1TokensErc1155ByOwnerAddressData>): QueryKey<Options<GetV1TokensErc1155ByOwnerAddressData>> => createQueryKey('getV1TokensErc1155ByOwnerAddress', options, true);

export const getV1TokensErc1155ByOwnerAddressInfiniteOptions = (options: Options<GetV1TokensErc1155ByOwnerAddressData>) => {
    return infiniteQueryOptions<GetV1TokensErc1155ByOwnerAddressResponse, DefaultError, InfiniteData<GetV1TokensErc1155ByOwnerAddressResponse>, QueryKey<Options<GetV1TokensErc1155ByOwnerAddressData>>, number | null | Pick<QueryKey<Options<GetV1TokensErc1155ByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1TokensErc1155ByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1TokensErc1155ByOwnerAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensErc1155ByOwnerAddressInfiniteQueryKey(options)
    });
};

export const getV1TokensPriceSupportedQueryKey = (options?: Options<GetV1TokensPriceSupportedData>) => createQueryKey('getV1TokensPriceSupported', options);

export const getV1TokensPriceSupportedOptions = (options?: Options<GetV1TokensPriceSupportedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensPriceSupported({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensPriceSupportedQueryKey(options)
    });
};

export const getV1TokensPriceQueryKey = (options?: Options<GetV1TokensPriceData>) => createQueryKey('getV1TokensPrice', options);

export const getV1TokensPriceOptions = (options?: Options<GetV1TokensPriceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensPrice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensPriceQueryKey(options)
    });
};

export const getV1TokensLookupQueryKey = (options: Options<GetV1TokensLookupData>) => createQueryKey('getV1TokensLookup', options);

export const getV1TokensLookupOptions = (options: Options<GetV1TokensLookupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1TokensLookup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1TokensLookupQueryKey(options)
    });
};

export const getV1ResolveByInputQueryKey = (options: Options<GetV1ResolveByInputData>) => createQueryKey('getV1ResolveByInput', options);

export const getV1ResolveByInputOptions = (options: Options<GetV1ResolveByInputData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1ResolveByInput({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1ResolveByInputQueryKey(options)
    });
};

export const getV1BlocksQueryKey = (options?: Options<GetV1BlocksData>) => createQueryKey('getV1Blocks', options);

export const getV1BlocksOptions = (options?: Options<GetV1BlocksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1Blocks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1BlocksQueryKey(options)
    });
};

export const getV1BlocksInfiniteQueryKey = (options?: Options<GetV1BlocksData>): QueryKey<Options<GetV1BlocksData>> => createQueryKey('getV1Blocks', options, true);

export const getV1BlocksInfiniteOptions = (options?: Options<GetV1BlocksData>) => {
    return infiniteQueryOptions<GetV1BlocksResponse, GetV1BlocksError, InfiniteData<GetV1BlocksResponse>, QueryKey<Options<GetV1BlocksData>>, number | null | Pick<QueryKey<Options<GetV1BlocksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1BlocksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1Blocks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1BlocksInfiniteQueryKey(options)
    });
};

export const getV1ContractsAbiByContractAddressQueryKey = (options: Options<GetV1ContractsAbiByContractAddressData>) => createQueryKey('getV1ContractsAbiByContractAddress', options);

export const getV1ContractsAbiByContractAddressOptions = (options: Options<GetV1ContractsAbiByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1ContractsAbiByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1ContractsAbiByContractAddressQueryKey(options)
    });
};

export const getV1ContractsMetadataByContractAddressQueryKey = (options: Options<GetV1ContractsMetadataByContractAddressData>) => createQueryKey('getV1ContractsMetadataByContractAddress', options);

export const getV1ContractsMetadataByContractAddressOptions = (options: Options<GetV1ContractsMetadataByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1ContractsMetadataByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1ContractsMetadataByContractAddressQueryKey(options)
    });
};

export const postV1DecodeByContractAddressQueryKey = (options: Options<PostV1DecodeByContractAddressData>) => createQueryKey('postV1DecodeByContractAddress', options);

export const postV1DecodeByContractAddressOptions = (options: Options<PostV1DecodeByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postV1DecodeByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postV1DecodeByContractAddressQueryKey(options)
    });
};

export const postV1DecodeByContractAddressMutation = (options?: Partial<Options<PostV1DecodeByContractAddressData>>): UseMutationOptions<PostV1DecodeByContractAddressResponse, PostV1DecodeByContractAddressError, Options<PostV1DecodeByContractAddressData>> => {
    const mutationOptions: UseMutationOptions<PostV1DecodeByContractAddressResponse, PostV1DecodeByContractAddressError, Options<PostV1DecodeByContractAddressData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postV1DecodeByContractAddress({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getV1NftsBalanceByOwnerAddressQueryKey = (options: Options<GetV1NftsBalanceByOwnerAddressData>) => createQueryKey('getV1NftsBalanceByOwnerAddress', options);

export const getV1NftsBalanceByOwnerAddressOptions = (options: Options<GetV1NftsBalanceByOwnerAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsBalanceByOwnerAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsBalanceByOwnerAddressQueryKey(options)
    });
};

export const getV1NftsBalanceByOwnerAddressInfiniteQueryKey = (options: Options<GetV1NftsBalanceByOwnerAddressData>): QueryKey<Options<GetV1NftsBalanceByOwnerAddressData>> => createQueryKey('getV1NftsBalanceByOwnerAddress', options, true);

export const getV1NftsBalanceByOwnerAddressInfiniteOptions = (options: Options<GetV1NftsBalanceByOwnerAddressData>) => {
    return infiniteQueryOptions<GetV1NftsBalanceByOwnerAddressResponse, DefaultError, InfiniteData<GetV1NftsBalanceByOwnerAddressResponse>, QueryKey<Options<GetV1NftsBalanceByOwnerAddressData>>, number | null | Pick<QueryKey<Options<GetV1NftsBalanceByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsBalanceByOwnerAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsBalanceByOwnerAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsBalanceByOwnerAddressInfiniteQueryKey(options)
    });
};

export const getV1NftsCollectionsByContractAddressQueryKey = (options: Options<GetV1NftsCollectionsByContractAddressData>) => createQueryKey('getV1NftsCollectionsByContractAddress', options);

export const getV1NftsCollectionsByContractAddressOptions = (options: Options<GetV1NftsCollectionsByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsCollectionsByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsCollectionsByContractAddressQueryKey(options)
    });
};

export const getV1NftsQueryKey = (options: Options<GetV1NftsData>) => createQueryKey('getV1Nfts', options);

export const getV1NftsOptions = (options: Options<GetV1NftsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1Nfts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsQueryKey(options)
    });
};

export const getV1NftsInfiniteQueryKey = (options: Options<GetV1NftsData>): QueryKey<Options<GetV1NftsData>> => createQueryKey('getV1Nfts', options, true);

export const getV1NftsInfiniteOptions = (options: Options<GetV1NftsData>) => {
    return infiniteQueryOptions<GetV1NftsResponse, GetV1NftsError, InfiniteData<GetV1NftsResponse>, QueryKey<Options<GetV1NftsData>>, number | null | Pick<QueryKey<Options<GetV1NftsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1Nfts({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsInfiniteQueryKey(options)
    });
};

export const getV1NftsOwnersByContractAddressQueryKey = (options: Options<GetV1NftsOwnersByContractAddressData>) => createQueryKey('getV1NftsOwnersByContractAddress', options);

export const getV1NftsOwnersByContractAddressOptions = (options: Options<GetV1NftsOwnersByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsOwnersByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsOwnersByContractAddressQueryKey(options)
    });
};

export const getV1NftsOwnersByContractAddressInfiniteQueryKey = (options: Options<GetV1NftsOwnersByContractAddressData>): QueryKey<Options<GetV1NftsOwnersByContractAddressData>> => createQueryKey('getV1NftsOwnersByContractAddress', options, true);

export const getV1NftsOwnersByContractAddressInfiniteOptions = (options: Options<GetV1NftsOwnersByContractAddressData>) => {
    return infiniteQueryOptions<GetV1NftsOwnersByContractAddressResponse, GetV1NftsOwnersByContractAddressError, InfiniteData<GetV1NftsOwnersByContractAddressResponse>, QueryKey<Options<GetV1NftsOwnersByContractAddressData>>, number | null | Pick<QueryKey<Options<GetV1NftsOwnersByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsOwnersByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsOwnersByContractAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsOwnersByContractAddressInfiniteQueryKey(options)
    });
};

export const getV1NftsOwnersByContractAddressByTokenIdQueryKey = (options: Options<GetV1NftsOwnersByContractAddressByTokenIdData>) => createQueryKey('getV1NftsOwnersByContractAddressByTokenId', options);

export const getV1NftsOwnersByContractAddressByTokenIdOptions = (options: Options<GetV1NftsOwnersByContractAddressByTokenIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsOwnersByContractAddressByTokenId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsOwnersByContractAddressByTokenIdQueryKey(options)
    });
};

export const getV1NftsOwnersByContractAddressByTokenIdInfiniteQueryKey = (options: Options<GetV1NftsOwnersByContractAddressByTokenIdData>): QueryKey<Options<GetV1NftsOwnersByContractAddressByTokenIdData>> => createQueryKey('getV1NftsOwnersByContractAddressByTokenId', options, true);

export const getV1NftsOwnersByContractAddressByTokenIdInfiniteOptions = (options: Options<GetV1NftsOwnersByContractAddressByTokenIdData>) => {
    return infiniteQueryOptions<GetV1NftsOwnersByContractAddressByTokenIdResponse, GetV1NftsOwnersByContractAddressByTokenIdError, InfiniteData<GetV1NftsOwnersByContractAddressByTokenIdResponse>, QueryKey<Options<GetV1NftsOwnersByContractAddressByTokenIdData>>, number | null | Pick<QueryKey<Options<GetV1NftsOwnersByContractAddressByTokenIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsOwnersByContractAddressByTokenIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsOwnersByContractAddressByTokenId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsOwnersByContractAddressByTokenIdInfiniteQueryKey(options)
    });
};

export const getV1NftsTransfersQueryKey = (options?: Options<GetV1NftsTransfersData>) => createQueryKey('getV1NftsTransfers', options);

export const getV1NftsTransfersOptions = (options?: Options<GetV1NftsTransfersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsTransfers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersQueryKey(options)
    });
};

export const getV1NftsTransfersInfiniteQueryKey = (options?: Options<GetV1NftsTransfersData>): QueryKey<Options<GetV1NftsTransfersData>> => createQueryKey('getV1NftsTransfers', options, true);

export const getV1NftsTransfersInfiniteOptions = (options?: Options<GetV1NftsTransfersData>) => {
    return infiniteQueryOptions<GetV1NftsTransfersResponse, GetV1NftsTransfersError, InfiniteData<GetV1NftsTransfersResponse>, QueryKey<Options<GetV1NftsTransfersData>>, number | null | Pick<QueryKey<Options<GetV1NftsTransfersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsTransfersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsTransfers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersInfiniteQueryKey(options)
    });
};

export const getV1NftsTransfersTransactionByTransactionHashQueryKey = (options: Options<GetV1NftsTransfersTransactionByTransactionHashData>) => createQueryKey('getV1NftsTransfersTransactionByTransactionHash', options);

export const getV1NftsTransfersTransactionByTransactionHashOptions = (options: Options<GetV1NftsTransfersTransactionByTransactionHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsTransfersTransactionByTransactionHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersTransactionByTransactionHashQueryKey(options)
    });
};

export const getV1NftsTransfersTransactionByTransactionHashInfiniteQueryKey = (options: Options<GetV1NftsTransfersTransactionByTransactionHashData>): QueryKey<Options<GetV1NftsTransfersTransactionByTransactionHashData>> => createQueryKey('getV1NftsTransfersTransactionByTransactionHash', options, true);

export const getV1NftsTransfersTransactionByTransactionHashInfiniteOptions = (options: Options<GetV1NftsTransfersTransactionByTransactionHashData>) => {
    return infiniteQueryOptions<GetV1NftsTransfersTransactionByTransactionHashResponse, GetV1NftsTransfersTransactionByTransactionHashError, InfiniteData<GetV1NftsTransfersTransactionByTransactionHashResponse>, QueryKey<Options<GetV1NftsTransfersTransactionByTransactionHashData>>, number | null | Pick<QueryKey<Options<GetV1NftsTransfersTransactionByTransactionHashData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsTransfersTransactionByTransactionHashData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsTransfersTransactionByTransactionHash({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersTransactionByTransactionHashInfiniteQueryKey(options)
    });
};

export const getV1NftsTransfersByContractAddressQueryKey = (options: Options<GetV1NftsTransfersByContractAddressData>) => createQueryKey('getV1NftsTransfersByContractAddress', options);

export const getV1NftsTransfersByContractAddressOptions = (options: Options<GetV1NftsTransfersByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsTransfersByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersByContractAddressQueryKey(options)
    });
};

export const getV1NftsTransfersByContractAddressInfiniteQueryKey = (options: Options<GetV1NftsTransfersByContractAddressData>): QueryKey<Options<GetV1NftsTransfersByContractAddressData>> => createQueryKey('getV1NftsTransfersByContractAddress', options, true);

export const getV1NftsTransfersByContractAddressInfiniteOptions = (options: Options<GetV1NftsTransfersByContractAddressData>) => {
    return infiniteQueryOptions<GetV1NftsTransfersByContractAddressResponse, GetV1NftsTransfersByContractAddressError, InfiniteData<GetV1NftsTransfersByContractAddressResponse>, QueryKey<Options<GetV1NftsTransfersByContractAddressData>>, number | null | Pick<QueryKey<Options<GetV1NftsTransfersByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsTransfersByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsTransfersByContractAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersByContractAddressInfiniteQueryKey(options)
    });
};

export const getV1NftsByContractAddressQueryKey = (options: Options<GetV1NftsByContractAddressData>) => createQueryKey('getV1NftsByContractAddress', options);

export const getV1NftsByContractAddressOptions = (options: Options<GetV1NftsByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsByContractAddressQueryKey(options)
    });
};

export const getV1NftsByContractAddressInfiniteQueryKey = (options: Options<GetV1NftsByContractAddressData>): QueryKey<Options<GetV1NftsByContractAddressData>> => createQueryKey('getV1NftsByContractAddress', options, true);

export const getV1NftsByContractAddressInfiniteOptions = (options: Options<GetV1NftsByContractAddressData>) => {
    return infiniteQueryOptions<GetV1NftsByContractAddressResponse, GetV1NftsByContractAddressError, InfiniteData<GetV1NftsByContractAddressResponse>, QueryKey<Options<GetV1NftsByContractAddressData>>, number | null | Pick<QueryKey<Options<GetV1NftsByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsByContractAddressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsByContractAddress({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsByContractAddressInfiniteQueryKey(options)
    });
};

export const getV1NftsTransfersByContractAddressByTokenIdQueryKey = (options: Options<GetV1NftsTransfersByContractAddressByTokenIdData>) => createQueryKey('getV1NftsTransfersByContractAddressByTokenId', options);

export const getV1NftsTransfersByContractAddressByTokenIdOptions = (options: Options<GetV1NftsTransfersByContractAddressByTokenIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsTransfersByContractAddressByTokenId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersByContractAddressByTokenIdQueryKey(options)
    });
};

export const getV1NftsTransfersByContractAddressByTokenIdInfiniteQueryKey = (options: Options<GetV1NftsTransfersByContractAddressByTokenIdData>): QueryKey<Options<GetV1NftsTransfersByContractAddressByTokenIdData>> => createQueryKey('getV1NftsTransfersByContractAddressByTokenId', options, true);

export const getV1NftsTransfersByContractAddressByTokenIdInfiniteOptions = (options: Options<GetV1NftsTransfersByContractAddressByTokenIdData>) => {
    return infiniteQueryOptions<GetV1NftsTransfersByContractAddressByTokenIdResponse, GetV1NftsTransfersByContractAddressByTokenIdError, InfiniteData<GetV1NftsTransfersByContractAddressByTokenIdResponse>, QueryKey<Options<GetV1NftsTransfersByContractAddressByTokenIdData>>, number | null | Pick<QueryKey<Options<GetV1NftsTransfersByContractAddressByTokenIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1NftsTransfersByContractAddressByTokenIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1NftsTransfersByContractAddressByTokenId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsTransfersByContractAddressByTokenIdInfiniteQueryKey(options)
    });
};

export const getV1NftsByContractAddressByTokenIdQueryKey = (options: Options<GetV1NftsByContractAddressByTokenIdData>) => createQueryKey('getV1NftsByContractAddressByTokenId', options);

export const getV1NftsByContractAddressByTokenIdOptions = (options: Options<GetV1NftsByContractAddressByTokenIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsByContractAddressByTokenId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsByContractAddressByTokenIdQueryKey(options)
    });
};

export const getV1NftsMetadataRefreshByContractAddressQueryKey = (options: Options<GetV1NftsMetadataRefreshByContractAddressData>) => createQueryKey('getV1NftsMetadataRefreshByContractAddress', options);

export const getV1NftsMetadataRefreshByContractAddressOptions = (options: Options<GetV1NftsMetadataRefreshByContractAddressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsMetadataRefreshByContractAddress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsMetadataRefreshByContractAddressQueryKey(options)
    });
};

export const getV1NftsMetadataRefreshByContractAddressByTokenIdQueryKey = (options: Options<GetV1NftsMetadataRefreshByContractAddressByTokenIdData>) => createQueryKey('getV1NftsMetadataRefreshByContractAddressByTokenId', options);

export const getV1NftsMetadataRefreshByContractAddressByTokenIdOptions = (options: Options<GetV1NftsMetadataRefreshByContractAddressByTokenIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1NftsMetadataRefreshByContractAddressByTokenId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1NftsMetadataRefreshByContractAddressByTokenIdQueryKey(options)
    });
};

export const getV1WalletsByWalletAddressTransactionsQueryKey = (options: Options<GetV1WalletsByWalletAddressTransactionsData>) => createQueryKey('getV1WalletsByWalletAddressTransactions', options);

export const getV1WalletsByWalletAddressTransactionsOptions = (options: Options<GetV1WalletsByWalletAddressTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1WalletsByWalletAddressTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1WalletsByWalletAddressTransactionsQueryKey(options)
    });
};

export const getV1WalletsByWalletAddressTransactionsInfiniteQueryKey = (options: Options<GetV1WalletsByWalletAddressTransactionsData>): QueryKey<Options<GetV1WalletsByWalletAddressTransactionsData>> => createQueryKey('getV1WalletsByWalletAddressTransactions', options, true);

export const getV1WalletsByWalletAddressTransactionsInfiniteOptions = (options: Options<GetV1WalletsByWalletAddressTransactionsData>) => {
    return infiniteQueryOptions<GetV1WalletsByWalletAddressTransactionsResponse, GetV1WalletsByWalletAddressTransactionsError, InfiniteData<GetV1WalletsByWalletAddressTransactionsResponse>, QueryKey<Options<GetV1WalletsByWalletAddressTransactionsData>>, number | null | Pick<QueryKey<Options<GetV1WalletsByWalletAddressTransactionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetV1WalletsByWalletAddressTransactionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getV1WalletsByWalletAddressTransactions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1WalletsByWalletAddressTransactionsInfiniteQueryKey(options)
    });
};