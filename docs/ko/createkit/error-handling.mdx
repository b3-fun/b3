---
title: 오류 처리
description: CreateKit을 위한 포괄적인 에러 처리 패턴 및 복구 전략
lang: ko
originalPath: createkit/error-handling.mdx
---
## 개요

CreateKit을 사용하는 프로덕션 애플리케이션에서는 견고한 오류 처리가 중요합니다. 이 가이드는 일반적인 오류 시나리오, 모범 사례 및 복구 전략을 다룹니다.

## 일반적인 오류 유형

### 서명 오류

```typescript title="서명 오류 처리"
import { CollectionManager } from '@b3dotfun/basemint'

async function handleSignatureErrors(walletClient: any, metadata: any) {
  try {
    const signature = await collectionManager.generateCreatorSignature(
      walletClient,
      metadata
    )
    return signature
  } catch (error: any) {
    if (error.message.includes('User rejected')) {
      throw new Error('SIGNATURE_REJECTED: 사용자가 서명 요청을 거부했습니다')
    } else if (error.message.includes('Insufficient funds')) {
      throw new Error('INSUFFICIENT_FUNDS: 가스 비용을 충당할 충분한 자금이 없습니다')
    } else if (error.message.includes('Network error')) {
      throw new Error('NETWORK_ERROR: 네트워크에 연결할 수 없습니다')
    } else {
      throw new Error(`SIGNATURE_FAILED: ${error.message}`)
    }
  }
}
```

### 저장소 오류

```typescript title="저장소 오류 처리"
import { BaseMintStorage } from '@b3dotfun/basemint'

async function handleStorageErrors(storage: BaseMintStorage, metadata: any, signature: string) {
  try {
    return await storage.submitCollection(metadata, signature)
  } catch (error: any) {
    if (error.message.includes('Invalid signature')) {
      throw new Error('INVALID_SIGNATURE: 서명 검증에 실패했습니다')
    } else if (error.message.includes('Collection exists')) {
      throw new Error('DUPLICATE_COLLECTION: 컬렉션이 이미 존재합니다')
    } else if (error.message.includes('Rate limit')) {
      throw new Error('RATE_LIMITED: 요청이 너무 많습니다. 나중에 다시 시도해 주세요')
    } else if (error.status === 503) {
      throw new Error('SERVICE_UNAVAILABLE: 저장소 서비스가 일시적으로 사용 불가능합니다')
    } else {
      throw new Error(`STORAGE_ERROR: ${error.message}`)
    }
  }
}
```

### 계약 상호작용 오류

```typescript title="계약 오류 처리"
async function handleMintingErrors(collection: any, walletClient: any, params: any) {
  try {
    return await collection.mint(walletClient, ...params)
  } catch (error: any) {
    if (error.message.includes('Invalid merkle proof')) {
      throw new Error('NOT_WHITELISTED: 주소가 화이트리스트에 없습니다')
    } else if (error.message.includes('Insufficient payment')) {
      throw new Error('INSUFFICIENT_PAYMENT: 민트 가격이 올바르지 않습니다')
    } else if (error.message.includes('Max per wallet exceeded')) {
      throw new Error('WALLET_LIMIT_EXCEEDED: 지갑당 민팅 한도에 도달했습니다')
    } else if (error.message.includes('Max supply exceeded')) {
      throw new Error('SUPPLY_EXHAUSTED: 컬렉션이 완전히 민트되었습니다')
    } else if (error.message.includes('Minting not active')) {
      throw new Error('MINTING_INACTIVE: 이 컬렉션의 민팅 기간이 아닙니다')
    } else {
      throw new Error(`MINT_FAILED: ${error.message}`)
    }
  }
}
```

## 오류 복구 패턴

### 재시도 로직

```typescript title="지수 백오프로 재시도"
async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  baseDelayMs: number = 1000
): Promise<T> {
  let lastError: Error
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation()
    } catch (error: any) {
      lastError = error
      
      // 특정 오류는 재시도하지 않음
      if (error.message.includes('SIGNATURE_REJECTED') ||
          error.message.includes('INVALID_SIGNATURE') ||
          error.message.includes('DUPLICATE_COLLECTION')) {
        throw error
      }
      
      if (attempt < maxRetries) {
        const delay = baseDelayMs * Math.pow(2, attempt - 1)
        console.warn(`시도 ${attempt} 실패, ${delay}ms 후에 재시도합니다...`)
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }
  
  throw lastError
}

// 사용 예
const result = await retryWithBackoff(async () => {
  return await storage.submitCollection(metadata, signature)
})
```

### 서킷 브레이커

```typescript title="서킷 브레이커 패턴"
class CircuitBreaker {
  private failures = 0
  private lastFailTime = 0
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED'
  
  constructor(
    private maxFailures: number = 5,
    private timeoutMs: number = 60000
  ) {}
  
  async call<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailTime > this.timeoutMs) {
        this.state = 'HALF_OPEN'
      } else {
        throw new Error('CIRCUIT_OPEN: 서비스가 일시적으로 사용 불가능합니다')
      }
    }
    
    try {
      const result = await operation()
      this.reset()
      return result
    } catch (error) {
      this.recordFailure()
      throw error
    }
  }
  
  private recordFailure() {
    this.failures++
    this.lastFailTime = Date.now()
    
    if (this.failures >= this.maxFailures) {
      this.state = 'OPEN'
    }
  }
  
  private reset() {
    this.failures = 0
    this.state = 'CLOSED'
  }
}

// 사용 예
const circuitBreaker = new CircuitBreaker()
const result = await circuitBreaker.call(() => storage.submitCollection(metadata, signature))
```

## 사용자 친화적인 오류 메시지

```typescript title="오류 메시지 번역"
const ERROR_MESSAGES = {
  SIGNATURE_REJECTED: "계속하려면 지갑에서 서명을 승인하세요.",
  INSUFFICIENT_FUNDS: "가스 비용을 충당할 충분한 자금이 없습니다.",
  NOT_WHITELISTED: "귀하의 주소는 화이트리스트 민팅에 적합하지 않습니다.",
  WALLET_LIMIT_EXCEEDED: "지갑당 토큰의 최대 수량에 도달했습니다.",
  SUPPLY_EXHAUSTED: "이 컬렉션은 완전히 민트되었습니다.",
  MINTING_INACTIVE: "현재 이 컬렉션에 대한 민팅이 활성화되어 있지 않습니다.",
  NETWORK_ERROR: "네트워크 연결 문제입니다. 인터넷을 확인하고 다시 시도해 주세요.",
  SERVICE_UNAVAILABLE: "서비스가 일시적으로 사용 불가능합니다. 몇 분 후에 다시 시도해 주세요.",
  RATE_LIMITED: "요청이 너무 많습니다. 잠시 후에 다시 시도해 주세요."
}

function getUserFriendlyError(error: Error): string {
  const errorCode = error.message.split(':')[0]
  return ERROR_MESSAGES[errorCode] || "예기치 않은 오류가 발생했습니다. 다시 시도해 주세요."
}

// React에서 사용
export function ErrorDisplay({ error }: { error: Error | null }) {
  if (!error) return null
  
  return (
    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
      <p>{getUserFriendlyError(error)}</p>
    </div>
  )
}
```

## 오류 모니터링

```typescript title="오류 추적"
class ErrorTracker {
  private errors: Array<{ timestamp: Date; error: Error; context: any }> = []
  
  track(error: Error, context: any = {}) {
    this.errors.push({
      timestamp: new Date(),
      error,
      context
    })
    
    // 모니터링 서비스로 전송
    this.sendToMonitoring(error, context)
  }
  
  private sendToMonitoring(error: Error, context: any) {
    // 오류 모니터링 서비스와의 통합
    console.error('추적된 오류:', {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    })
  }
  
  getErrorStats() {
    const last24h = this.errors.filter(
      e => Date.now() - e.timestamp.getTime() < 24 * 60 * 60 * 1000
    )
    
    return {
      total: this.errors.length,
      last24h: last24h.length,
      mostCommon: this.getMostCommonErrors()
    }
  }
  
  private getMostCommonErrors() {
    const errorCounts = new Map<string, number>()
    
    this.errors.forEach(({ error }) => {
      const errorType = error.message.split(':')[0]
      errorCounts.set(errorType, (errorCounts.get(errorType) || 0) + 1)
    })
    
    return Array.from(errorCounts.entries())
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
  }
}

// 전역 오류 추적기
export const errorTracker = new ErrorTracker()
```

## 입력 유효성 검사 도우미

```typescript title="입력 유효성 검사"
export class ValidationError extends Error {
  constructor(field: string, message: string) {
    super(`${field}: ${message}`)
    this.name = 'ValidationError'
  }
}

export function validateCollectionMetadata(metadata: any): void {
  if (!metadata.name || metadata.name.length < 1) {
    throw new ValidationError('name', '컬렉션 이름은 필수입니다')
  }
  
  if (!metadata.symbol || metadata.symbol.length < 1) {
    throw new ValidationError('symbol', '컬렉션 심볼은 필수입니다')
  }
  
  if (!metadata.creator || !isValidAddress(metadata.creator)) {
    throw new ValidationError('creator', '유효한 생성자 주소가 필요합니다')
  }
  
  if (metadata.maxSupply && metadata.maxSupply <= 0n) {
    throw new ValidationError('maxSupply', '최대 공급량은 0보다 커야 합니다')
  }
  
  if (metadata.mintPrice && metadata.mintPrice < 0n) {
    throw new ValidationError('mintPrice', '민트 가격은 음수일 수 없습니다')
  }
}

function isValidAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address)
}
```

## React 오류 경계

```tsx title="오류 경계 컴포넌트"
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class CreateKitErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('CreateKit 오류 경계에서 오류가 발생했습니다:', error, errorInfo)
    
    // 오류 추적
    errorTracker.track(error, { errorInfo })
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="bg-red-50 border border-red-200 rounded-lg p-6">
          <h2 className="text-red-800 text-lg font-semibold mb-2">
            문제가 발생했습니다
          </h2>
          <p className="text-red-600">
            {getUserFriendlyError(this.state.error!)}
          </p>
          <button
            onClick={() => this.setState({ hasError: false })}
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
          >
            다시 시도하기
          </button>
        </div>
      )
    }

    return this.props.children
  }
}
```

## 모범 사례

<CardGroup cols={2}>
  <Card title="오류 분류" icon="tags">
    - 오류 유형 및 심각도별로 분류
    - 일관된 오류 코드 사용
    - 실행 가능한 오류 메시지 제공
    - 충분한 컨텍스트와 함께 오류 로깅
  </Card>
  <Card title="복구 전략" icon="refresh">
    - 적절한 재시도 로직 구현
    - 외부 서비스에 대해 서킷 브레이커 사용
    - 폴백 메커니즘 제공
    - 수동 오류 복구 허용
  </Card>
</CardGroup>

## 다음 단계

이제 CreateKit 문서를 종합적으로 갖추었으니, 다음을 수행할 수 있습니다:

<CardGroup cols={2}>
  <Card title="빌드 시작" icon="hammer">
    빠른 시작 가이드를 사용하여 첫 컬렉션 생성
  </Card>
  <Card title="커뮤니티 가입" icon="users">
    B3 Discord에서 다른 개발자들과 연결
  </Card>
</CardGroup>
