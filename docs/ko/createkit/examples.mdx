---
title: ì˜ˆì‹œë“¤
description: CreateKit ì‚¬ìš© ì‚¬ë¡€ì— ëŒ€í•œ ì™„ë²½í•œ êµ¬í˜„ ì˜ˆì‹œ
lang: ko
originalPath: createkit/examples.mdx
---
## ê°œìš”

ì´ í˜ì´ì§€ëŠ” ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ CreateKitì„ êµ¬í˜„í•˜ëŠ” ì‹¤ì œ ì˜ˆì œë¥¼ ì¢…í•©ì ìœ¼ë¡œ ì œê³µí•©ë‹ˆë‹¤. ê° ì˜ˆì œì—ëŠ” ì™„ì „í•œ ì½”ë“œ, ì˜¤ë¥˜ ì²˜ë¦¬ ë° ëª¨ë²” ì‚¬ë¡€ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

## ê¸°ë³¸ NFT ì»¬ë ‰ì…˜

ë¬´ë£Œ ë¯¼íŒ…ì´ ê°€ëŠ¥í•œ ê°„ë‹¨í•œ ì•„íŠ¸ ì»¬ë ‰ì…˜:

```typescript title="ê¸°ë³¸ ì•„íŠ¸ ì»¬ë ‰ì…˜"
import { 
  CollectionManager, 
  BaseMintStorage, 
  b3Testnet 
} from '@b3dotfun/basemint'
import { createPublicClient, createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

async function createBasicArtCollection() {
  // í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`)
  const publicClient = createPublicClient({
    chain: b3Testnet,
    transport: http()
  })
  const walletClient = createWalletClient({
    chain: b3Testnet,
    transport: http(),
    account
  })

  // ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
  const collectionManager = new CollectionManager(publicClient)
  const storage = new BaseMintStorage({ baseUrl: 'https://api.basemint.fun' })

  // ì»¬ë ‰ì…˜ ì •ì˜
  const artCollection = {
    name: "Digital Art Gallery",
    symbol: "DAG", 
    creator: account.address,
    gameOwner: account.address,
    description: "A curated collection of digital artworks",
    image: "https://example.com/art-collection.png",
    maxSupply: 1000n,
    mintPrice: 0n, // ë¬´ë£Œ ë¯¼íŒ…
    maxPerWallet: 5n,
    tokenStandard: "ERC721" as const,
    chainId: 1993
  }

  try {
    console.log("ğŸ¨ ì•„íŠ¸ ì»¬ë ‰ì…˜ ìƒì„± ì¤‘...")

    // ìƒì„±ì ì„œëª… ìƒì„±
    const creatorSignature = await collectionManager.generateCreatorSignature(
      walletClient,
      artCollection
    )

    // ì£¼ì†Œ ì˜ˆì¸¡
    const predictedAddress = collectionManager.predictCollectionAddress(
      artCollection,
      creatorSignature
    )
    console.log(`ğŸ“ ì»¬ë ‰ì…˜ ì£¼ì†Œ: ${predictedAddress}`)

    // ìŠ¤í† ë¦¬ì§€ì— ì œì¶œ
    await storage.submitCollection(artCollection, creatorSignature)
    console.log("âœ… ì»¬ë ‰ì…˜ ë©”íƒ€ë°ì´í„° ì €ì¥ë¨")

    // ë°°í¬ ë° ì²« NFT ë¯¼íŒ…
    const deployerSignature = await collectionManager.generateDeployerSignature(
      walletClient,
      predictedAddress
    )

    const collection = collectionManager.createCollection(predictedAddress, "ERC721")
    const mintTx = await collection.mint(
      walletClient,
      1n,
      undefined,
      0n,
      [],
      creatorSignature,
      deployerSignature
    )

    console.log(`ğŸ‰ ì»¬ë ‰ì…˜ ë°°í¬ ë° ì²« NFT ë¯¼íŒ…ë¨: ${mintTx}`)
    return { collection, predictedAddress, mintTx }

  } catch (error) {
    console.error("âŒ ì•„íŠ¸ ì»¬ë ‰ì…˜ ìƒì„± ì‹¤íŒ¨:", error)
    throw error
  }
}

// ì‚¬ìš©ë²•
createBasicArtCollection()
  .then(result => console.log("ì»¬ë ‰ì…˜ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë¨:", result))
  .catch(error => console.error("ìƒì„± ì‹¤íŒ¨:", error))
```

## í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ê°€ ìˆëŠ” ê²Œì´ë° ì»¬ë ‰ì…˜

ê³„ì¸µí™”ëœ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì•¡ì„¸ìŠ¤ê°€ ìˆëŠ” ê²Œì´ë° ì»¬ë ‰ì…˜:

<Accordion title="ì™„ì „í•œ ê²Œì´ë° ì»¬ë ‰ì…˜ ì˜ˆì œ">
```typescript
import { 
  CollectionManager, 
  WhitelistManager,
  BaseMintStorage,
  RewardTracker,
  b3Testnet 
} from '@b3dotfun/basemint'
import { createPublicClient, createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

class GamingCollectionManager {
  private publicClient: any
  private walletClient: any
  private collectionManager: CollectionManager
  private storage: BaseMintStorage
  private rewardTracker: RewardTracker

  constructor(privateKey: string) {
    const account = privateKeyToAccount(privateKey as `0x${string}`)
    
    this.publicClient = createPublicClient({
      chain: b3Testnet,
      transport: http()
    })
    
    this.walletClient = createWalletClient({
      chain: b3Testnet,
      transport: http(),
      account
    })

    this.collectionManager = new CollectionManager(this.publicClient)
    this.storage = new BaseMintStorage({ baseUrl: 'https://api.basemint.fun' })
    this.rewardTracker = new RewardTracker(this.publicClient)
  }

  async createGamingCollection() {
    // í”Œë ˆì´ì–´ ê³„ì¸µ ì •ì˜
    const playerTiers = {
      legendary: [
        "0x1111111111111111111111111111111111111111",
        "0x2222222222222222222222222222222222222222"
      ],
      epic: [
        "0x3333333333333333333333333333333333333333",
        "0x4444444444444444444444444444444444444444",
        "0x5555555555555555555555555555555555555555"
      ],
      rare: [
        "0x6666666666666666666666666666666666666666",
        "0x7777777777777777777777777777777777777777",
        "0x8888888888888888888888888888888888888888"
      ]
    }

    // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ìƒì„±
    const allPlayers = [
      ...playerTiers.legendary.map(address => ({ address })),
      ...playerTiers.epic.map(address => ({ address })),
      ...playerTiers.rare.map(address => ({ address }))
    ]

    const whitelist = new WhitelistManager(allPlayers)
    const merkleRoot = whitelist.getRoot()

    // ì»¬ë ‰ì…˜ ì •ì˜
    const gamingCollection = {
      name: "Legendary Gaming Items",
      symbol: "LGI",
      creator: this.walletClient.account.address,
      gameOwner: "0x9999999999999999999999999999999999999999", // ê²Œì„ í”Œë«í¼
      description: "Top playersë¥¼ ìœ„í•œ ë…ì  ê²Œì´ë° ì•„ì´í…œ",
      image: "https://example.com/gaming-collection.png",
      
      // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ êµ¬ì„±
      isWhitelistEnabled: true,
      whitelistMerkleRoot: merkleRoot,
      
      // ê°€ê²© ë° ì œí•œ
      maxSupply: 500n,
      mintPrice: parseEther("0.01"),
      maxPerWallet: 3n,
      
      // íƒ€ì´ë° - í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë‹¨ê³„ 24ì‹œê°„
      startTime: BigInt(Math.floor(Date.now() / 1000)),
      endTime: BigInt(Math.floor(Date.now() / 1000) + 86400 * 7),
      
      tokenStandard: "ERC1155" as const,
      chainId: 1993,
      
      // ê²Œì„ë³„ ë©”íƒ€ë°ì´í„°
      attributes: [
        { trait_type: "Category", value: "Gaming" },
        { trait_type: "Rarity", value: "Legendary" },
        { trait_type: "Game", value: "Fantasy RPG" }
      ]
    }

    try {
      console.log("ğŸ® ê²Œì´ë° ì»¬ë ‰ì…˜ ìƒì„± ì¤‘...")

      // ì„œëª… ìƒì„±
      const creatorSignature = await this.collectionManager.generateCreatorSignature(
        this.walletClient,
        gamingCollection
      )

      const predictedAddress = this.collectionManager.predictCollectionAddress(
        gamingCollection,
        creatorSignature
      )

      // ê²Œì„ ë¦¬í¼ëŸ¬ì™€ í•¨ê»˜ ìŠ¤í† ë¦¬ì§€ì— ì œì¶œ
      await this.storage.submitCollection(
        gamingCollection,
        creatorSignature,
        "fantasy-rpg-game" // ë¦¬í¼ëŸ¬ ID
      )

      console.log(`âœ… ê²Œì´ë° ì»¬ë ‰ì…˜ ì €ì¥ë¨: ${predictedAddress}`)

      return {
        collection: gamingCollection,
        predictedAddress,
        whitelist,
        playerTiers
      }

    } catch (error) {
      console.error("âŒ ê²Œì´ë° ì»¬ë ‰ì…˜ ìƒì„± ì‹¤íŒ¨:", error)
      throw error
    }
  }

  async mintForPlayer(
    collectionAddress: string,
    whitelist: WhitelistManager,
    playerAddress: string,
    quantity: bigint = 1n
  ) {
    try {
      // ì»¬ë ‰ì…˜ì´ ë°°í¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
      const collection = this.collectionManager.createCollection(collectionAddress, "ERC1155")
      const isDeployed = await collection.isDeployed()

      if (!isDeployed) {
        // ì²« ë²ˆì§¸ ë¯¼íŠ¸ - ì»¬ë ‰ì…˜ ë°°í¬
        const deployerSignature = await this.collectionManager.generateDeployerSignature(
          this.walletClient,
          collectionAddress
        )

        // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì¦ëª… ê°€ì ¸ì˜¤ê¸°
        const proof = whitelist.getProof(playerAddress)
        const mintPrice = parseEther("0.01") * quantity

        const tx = await collection.mint(
          this.walletClient,
          quantity,
          "https://example.com/legendary-sword.json", // íŠ¹ì • ì•„ì´í…œ ë©”íƒ€ë°ì´í„°
          mintPrice,
          proof,
          undefined, // ë°°í¬ë¥¼ ìœ„í•´ í•„ìš”í•œ creatorSignature
          deployerSignature
        )

        console.log(`ğŸš€ ì»¬ë ‰ì…˜ ë°°í¬ ë° ì•„ì´í…œ ë¯¼íŒ…ë¨: ${tx}`)
        return tx

      } else {
        // ì¼ë°˜ ë¯¼íŠ¸
        const proof = whitelist.getProof(playerAddress)
        const mintPrice = parseEther("0.01") * quantity

        const tx = await collection.mint(
          this.walletClient,
          quantity,
          "https://example.com/legendary-sword.json",
          mintPrice,
          proof
        )

        console.log(`âš”ï¸ ê²Œì´ë° ì•„ì´í…œ ë¯¼íŒ…ë¨: ${tx}`)
        return tx
      }

    } catch (error: any) {
      if (error.message.includes('Invalid merkle proof')) {
        console.error(`âŒ í”Œë ˆì´ì–´ ${playerAddress} í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì— ì—†ìŒ`)
      } else {
        console.error("âŒ ë¯¼íŒ… ì‹¤íŒ¨:", error)
      }
      throw error
    }
  }

  async getPlayerRewards(collectionAddress: string, playerAddress: string) {
    const escrowAddress = this.collectionManager.getEscrowAddress()
    
    // í”Œë ˆì´ì–´ê°€ ì²« ë²ˆì§¸ ë¯¼í„°ì¸ì§€ í™•ì¸
    const firstMinterRewards = await this.rewardTracker.getRecipientRewards(
      escrowAddress,
      collectionAddress,
      "FIRST_MINTER",
      playerAddress
    )

    // ì»¬ë ‰ì…˜ í†µê³„ ê°€ì ¸ì˜¤ê¸°
    const collectionRewards = await this.rewardTracker.getCollectionRewards(
      escrowAddress,
      collectionAddress
    )

    return {
      firstMinterRewards: firstMinterRewards.toString(),
      collectionTotalRewards: collectionRewards.totalRewards.toString(),
      collectionMints: collectionRewards.totalMints.toString()
    }
  }
}

// ì‚¬ìš© ì˜ˆì œ
async function main() {
  const gameManager = new GamingCollectionManager(process.env.PRIVATE_KEY!)
  
  // ì»¬ë ‰ì…˜ ìƒì„±
  const { predictedAddress, whitelist, playerTiers } = await gameManager.createGamingCollection()
  
  // ì „ì„¤ì ì¸ í”Œë ˆì´ì–´ ë¯¼íŒ… ì‹œë®¬ë ˆì´ì…˜
  const legendaryPlayer = playerTiers.legendary[0]
  await gameManager.mintForPlayer(predictedAddress, whitelist, legendaryPlayer, 2n)
  
  // ë³´ìƒ í™•ì¸
  const rewards = await gameManager.getPlayerRewards(predictedAddress, legendaryPlayer)
  console.log("í”Œë ˆì´ì–´ ë³´ìƒ:", rewards)
}

main().catch(console.error)
```
</Accordion>

## ë©€í‹° ì»¬ë ‰ì…˜ í”Œë«í¼

ì—¬ëŸ¬ ì»¬ë ‰ì…˜ì„ ê´€ë¦¬í•˜ëŠ” í”Œë«í¼:

<Accordion title="ë©€í‹° ì»¬ë ‰ì…˜ í”Œë«í¼ ì˜ˆì œ">
```typescript
import { 
  CollectionManager, 
  BaseMintStorage,
  RewardTracker,
  b3Testnet 
} from '@b3dotfun/basemint'

class NFTPlatform {
  private collectionManager: CollectionManager
  private storage: BaseMintStorage
  private rewardTracker: RewardTracker
  private platformId: string

  constructor(
    publicClient: any,
    platformId: string
  ) {
    this.collectionManager = new CollectionManager(publicClient)
    this.storage = new BaseMintStorage({ baseUrl: 'https://api.basemint.fun' })
    this.rewardTracker = new RewardTracker(publicClient)
    this.platformId = platformId
  }

  async registerPlatform() {
    try {
      await this.storage.registerReferrer(this.platformId, {
        name: "My NFT Platform",
        website: "https://mynftplatform.com",
        description: "NFT ì»¬ë ‰ì…˜ì„ ìƒì„±í•˜ê³  ê´€ë¦¬í•˜ëŠ” í”Œë«í¼"
      })
      console.log(`âœ… í”Œë«í¼ ë“±ë¡ë¨: ${this.platformId}`)
    } catch (error: any) {
      if (error.message.includes('already exists')) {
        console.log(`â„¹ï¸ í”Œë«í¼ ${this.platformId} ì´ë¯¸ ë“±ë¡ë¨`)
      } else {
        throw error
      }
    }
  }

  async createCollection(
    creatorWalletClient: any,
    collectionData: {
      name: string
      symbol: string
      description: string
      image: string
      maxSupply: bigint
      mintPrice: bigint
      category: string
    }
  ) {
    const collection = {
      ...collectionData,
      creator: creatorWalletClient.account.address,
      gameOwner: creatorWalletClient.account.address, // í”Œë«í¼ì´ gameOwnerì¼ ìˆ˜ ìˆìŒ
      tokenStandard: "ERC721" as const,
      chainId: 1993,
      attributes: [
        { trait_type: "Platform", value: "My NFT Platform" },
        { trait_type: "Category", value: collectionData.category }
      ]
    }

    // ì„œëª… ìƒì„± ë° ì €ì¥
    const creatorSignature = await this.collectionManager.generateCreatorSignature(
      creatorWalletClient,
      collection
    )

    const predictedAddress = this.collectionManager.predictCollectionAddress(
      collection,
      creatorSignature
    )

    await this.storage.submitCollection(
      collection,
      creatorSignature,
      this.platformId
    )

    return {
      collection,
      predictedAddress,
      creatorSignature
    }
  }

  async deployCollection(
    deployerWalletClient: any,
    collectionAddress: string,
    creatorSignature: string
  ) {
    const deployerSignature = await this.collectionManager.generateDeployerSignature(
      deployerWalletClient,
      collectionAddress
    )

    const collection = this.collectionManager.createCollection(collectionAddress, "ERC721")
    
    const tx = await collection.mint(
      deployerWalletClient,
      1n,
      undefined,
      0n, // ë°°í¬ìì—ê²Œ ì²« ë²ˆì§¸ ë¯¼íŠ¸ ë¬´ë£Œ
      [],
      creatorSignature,
      deployerSignature
    )

    return tx
  }

  async getPlatformStats() {
    const collections = await this.storage.queryCollections({
      referrer: this.platformId
    })

    const stats = {
      totalCollections: collections.total,
      deployed: 0,
      undeployed: 0,
      totalVolume: 0n,
      totalRewards: 0n
    }

    const escrowAddress = this.collectionManager.getEscrowAddress()

    for (const collection of collections.collections) {
      if (collection.isDeployed) {
        stats.deployed++
        
        // ì»¬ë ‰ì…˜ ë³´ìƒ ê°€ì ¸ì˜¤ê¸°
        const rewards = await this.rewardTracker.getCollectionRewards(
          escrowAddress,
          collection.address
        )
        stats.totalRewards += rewards.totalRewards
      } else {
        stats.undeployed++
      }
    }

    return {
      ...stats,
      collections: collections.collections
    }
  }

  async getCreatorDashboard(creatorAddress: string) {
    const collections = await this.storage.queryCollections({
      creator: creatorAddress,
      referrer: this.platformId
    })

    const escrowAddress = this.collectionManager.getEscrowAddress()
    let totalCreatorRewards = 0n

    const collectionStats = await Promise.all(
      collections.collections.map(async (collection) => {
        if (collection.isDeployed) {
          const rewards = await this.rewardTracker.getRecipientRewards(
            escrowAddress,
            collection.address,
            "CREATOR",
            creatorAddress
          )
          totalCreatorRewards += rewards
          
          return {
            ...collection,
            creatorRewards: rewards.toString()
          }
        }
        return {
          ...collection,
          creatorRewards: "0"
        }
      })
    )

    return {
      totalCollections: collections.total,
      totalCreatorRewards: totalCreatorRewards.toString(),
      collections: collectionStats
    }
  }
}

// ì‚¬ìš©
async function runPlatform() {
  const publicClient = createPublicClient({
    chain: b3Testnet,
    transport: http()
  })

  const platform = new NFTPlatform(publicClient, "my-nft-platform")
  
  // í”Œë«í¼ ë“±ë¡
  await platform.registerPlatform()
  
  // í¬ë¦¬ì—ì´í„°ê°€ ì»¬ë ‰ì…˜ ìƒì„±
  const creatorAccount = privateKeyToAccount(process.env.CREATOR_PRIVATE_KEY as `0x${string}`)
  const creatorWalletClient = createWalletClient({
    chain: b3Testnet,
    transport: http(),
    account: creatorAccount
  })

  const { predictedAddress,
