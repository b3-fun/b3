---
title: 구매자를 위한 빠른 시작 가이드
description: AnySpend x402 Client SDK를 사용하여 모든 토큰으로 유료 API 및 서비스에 대한 비용을 지불하세요
lang: ko
originalPath: anyspend/x402-quickstart-buyers.mdx
---
## 개요

이 가이드는 **AnySpend x402 Client SDK**를 사용하여 보유한 암호화폐로 유료 리소스를 결제하는 방법을 보여줍니다. SDK는 서명 생성 및 재시도 로직을 포함한 전체 결제 흐름을 자동으로 처리합니다.

x402의 장점은 AnySpend을 사용하는 것뿐만 아니라 **모든 x402 지원 서비스**에 대해 동일한 클라이언트를 사용할 수 있다는 것입니다.

## 필수 조건

시작하기 전에 다음이 있는지 확인하세요:

- **Node.js 18+** 또는 호환 가능한 JavaScript 런타임
- 일부 토큰이 있는 **암호화폐 지갑** (ETH, USDC, DAI 등)
- [viem](https://viem.sh) 또는 [ethers.js](https://docs.ethers.org)와 같은 **지갑 라이브러리**
- 유료 API와 같은 **x402 지원 서비스에 대한 접근 권한**

## 설치

x402 클라이언트 SDK 설치:

<CodeGroup>
```bash npm
npm install anyspend-x402-client viem
```

```bash yarn
yarn add anyspend-x402-client viem
```

```bash pnpm
pnpm add anyspend-x402-client viem
```
</CodeGroup>

SDK는 지갑 작업 및 서명 생성을 위해 [viem](https://viem.sh)을 사용합니다.

## 기본 사용법

### 1. 지갑 클라이언트 생성

먼저 viem을 사용하여 지갑 클라이언트를 설정합니다:

```typescript
import { createWalletClient, custom } from 'viem';
import { base } from 'viem/chains';

// MetaMask 또는 다른 지갑 확장 프로그램이 있는 브라우저용
const walletClient = createWalletClient({
  chain: base,
  transport: custom(window.ethereum)
});

// 사용자의 주소 가져오기
const [address] = await walletClient.getAddresses();
```

### 2. x402 클라이언트 초기화

x402 클라이언트의 인스턴스를 생성합니다:

```typescript
import { X402Client } from 'anyspend-x402-client';

const x402Client = new X402Client({
  walletClient,           // viem 지갑 클라이언트
  preferredToken: '0x...', // 선택 사항: 기본 결제 토큰
  autoRetry: true          // 402 응답 자동 처리 (기본값: true)
});
```

### 3. 유료 요청하기

클라이언트를 사용하여 유료 리소스에 접근합니다:

```typescript
try {
  const response = await x402Client.request(
    'https://api.example.com/premium-data',
    {
      method: 'GET',
    }
  );

  console.log('Data:', response.data);
  console.log('Payment TX:', response.paymentResponse?.txHash);
} catch (error) {
  console.error('Payment failed:', error);
}
```

**어떤 일이 일어나나요:**

1. 클라이언트가 초기 요청을 합니다
2. API는 결제 세부 정보와 함께 `402 Payment Required`를 반환합니다
3. X402Client가 자동으로 결제 승인을 서명합니다
4. 클라이언트가 결제와 함께 요청을 재시도합니다
5. API가 결제를 검증하고 정산합니다
6. 클라이언트가 요청한 데이터를 받습니다

## 고급 사용법

### 결제 토큰 지정

결제에 사용할 토큰을 지정하는 두 가지 방법이 있습니다:

#### 옵션 1: X402Client 사용

`preferredToken`을 설정하여 특정 토큰으로 결제합니다:

```typescript
const response = await x402Client.request(
  'https://ai-agent-api.com/inference',
  {
    method: 'POST',
    body: { prompt: '고양이 이미지 생성' },
    preferredToken: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb' // Base의 DAI
  }
);
```

#### 옵션 2: wrapFetchWithPayment 사용 (고급)

더 많은 제어가 필요한 경우 하위 수준의 `wrapFetchWithPayment` 함수를 사용합니다:

```typescript
import { wrapFetchWithPayment } from 'anyspend-x402-client';

const tokenAddress = '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb'; // Base의 DAI
const selectedChain = 8453; // Base

const paymentPreferences = {
  preferredToken: tokenAddress,
  preferredNetwork: 'base' as const, // 또는 getNetworkName(selectedChain) 사용
};

console.log(`💡 기본 토큰 사용: ${tokenAddress} on base`);

// 자동 결제 처리를 위해 fetch를 wrap
const fetchWithPayment = wrapFetchWithPayment(
  fetch,
  walletClient,
  '1000000', // 최대 결제 금액 (6자리 소수점으로 1 USDC)
  undefined, // 기본 결제 요구 사항 선택기 사용
  undefined, // 기본 설정 사용
  paymentPreferences, // 선호하는 토큰과 네트워크 지정
);

// 일반 fetch처럼 wrap된 fetch 사용
const response = await fetchWithPayment('https://api.example.com/premium-data');
const data = await response.json();
```

**`wrapFetchWithPayment`의 이점:**
- 기존 `fetch` 기반 코드와 함께 작동합니다
- 결제 동작에 대한 더 세밀한 제어를 제공합니다
- 최대 결제 금액을 지정할 수 있습니다
- 사용자 정의 결제 요구 사항 선택기
- 다중 네트워크 서명자 지원

리소스 서버가 AnySpend 미들웨어를 지원하는 경우, USDC 대신 선호하는 토큰으로 동일한 금액을 지불합니다.

### 본문이 있는 POST 요청

유료 POST 요청을 만듭니다:

```typescript
const response = await x402Client.request(
  'https://api.example.com/compute',
  {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: {
      model: 'gpt-4',
      messages: [{ role: 'user', content: '안녕하세요!' }]
    }
  }
);
```

### 수동 결제 흐름

결제 흐름을 수동으로 처리합니다:

```typescript
// 1. 초기 요청을 합니다
const initialResponse = await fetch('https://api.example.com/premium-data');

if (initialResponse.status === 402) {
  // 2. 결제 요구 사항을 파싱합니다
  const paymentRequired = await initialResponse.json();
  const requirements = paymentRequired.requirements[0];

  console.log('Payment required:', {
    amount: requirements.amount,
    token: requirements.asset,
    recipient: requirements.recipient
  });

  // 3. 결제 승인을 서명합니다
  const paymentHeader = await x402Client.signPayment(requirements);

  // 4. 결제와 함께 재시도합니다
  const paidResponse = await fetch('https://api.example.com/premium-data', {
    headers: {
      'X-PAYMENT': paymentHeader
    }
  });

  const data = await paidResponse.json();
  const paymentResponse = paidResponse.headers.get('X-PAYMENT-RESPONSE');

  console.log('Payment successful!', JSON.parse(atob(paymentResponse)));
}
```

## 설정 옵션

### X402ClientOptions

```typescript
interface X402ClientOptions {
  walletClient: WalletClient;        // viem 지갑 클라이언트 (필수)
  network?: string;                   // 기본 네트워크 (예: 'base-mainnet')
  preferredToken?: string;            // 선호하는 결제 토큰 주소
  autoRetry?: boolean;                // 402에 대한 자동 재시도 (기본값: true)
  timeout?: number;                   // 요청 타임아웃(ms 단위) (기본값: 30000)
}
```

### RequestOptions

```typescript
interface RequestOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  headers?: Record<string, string>;
  body?: any;                         // 요청 본문 (JSON으로 자동 직렬화)
  preferredToken?: string;            // 기본 선호 토큰 덮어쓰기
}
```

### wrapFetchWithPayment 매개변수

고급 사용 사례의 경우, `wrapFetchWithPayment`는 하위 수준 제어를 제공합니다:

```typescript
function wrapFetchWithPayment(
  fetchFn: typeof fetch,              // 래핑할 Fetch 함수
  signer: Signer | MultiNetworkSigner, // 서명을 위한 지갑 클라이언트
  maxPaymentValue: string,             // 최소 단위로 최대 결제 (예: '1000000'은 1 USDC)
  selectPaymentRequirements?: Function, // 사용자 정의 요구 사항 선택기
  config?: {
    timeout?: number;                  // 요청 타임아웃(ms 단위)
    maxRetries?: number;               // 최대 결제 재시도 횟수
  },
  paymentPreferences?: {
    preferredToken?: string;           // 결제에 사용할 토큰 주소
    preferredNetwork?: string;         // 네트워크 식별자 (예: 'base', 'ethereum')
  }
): typeof fetch
```

**모든 매개변수를 사용한 예시:**

```typescript
import { wrapFetchWithPayment } from 'anyspend-x402-client';

const fetchWithPayment = wrapFetchWithPayment(
  fetch,
  walletClient,
  '5000000', // 최대 5 USDC
  undefined, // 기본 요구 사항 선택기 사용
  {
    timeout: 60000,    // 60초 타임아웃
    maxRetries: 3      // 최대 3회 재시도
  },
  {
    preferredToken: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', // DAI
    preferredNetwork: 'base'
  }
);
```

## 지원되는 토큰

x402 클라이언트는 **EIP-2612 permit**을 지원하거나 **USDC** (EIP-3009 transferWithAuthorization 사용)인 모든 토큰으로 결제할 수 있습니다.

일반적으로 지원되는 토큰:

- **USDC** - 모든 체인에서 기본 지원
- **DAI** - permit 지원이 있는 스테이블코인
- **USDT** - permit을 구현하는 체인에서

체인별 상세한 토큰 주소는 [네트워크 지원](/anyspend/x402-network-support)에서 확인하세요.

## 예시

### React 컴포넌트 (X402Client 사용)

```tsx
import { X402Client } from 'anyspend-x402-client';
import { useWalletClient } from 'wagmi';
import { useState } from 'react';

export function PremiumDataFetcher() {
  const { data: walletClient } = useWalletClient();
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchPremiumData = async () => {
    if (!walletClient) return;

    setLoading(true);
    try {
      const client = new X402Client({
        walletClient,
        preferredToken: '0x...' // DAI 또는 다른 토큰
      });

      const response = await client.request(
        'https://api.example.com/premium-data'
      );

      setData(response.data);
      console.log('TX로 결제:', response.paymentResponse?.txHash);
    } catch (error) {
      console.error('결제 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={fetchPremiumData} disabled={loading}>
        {loading ? '결제 중...' : '프리미엄 데이터 가져오기 (1 USDC 비용)'}
      </button>
      {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
    </div>
  );
}
```

### React 컴포넌트 (wrapFetchWithPayment 사용)

기존 fetch 기반 코드를 사용하거나 더 많은 제어가 필요한 애플리케이션의 경우:

```tsx
import { wrapFetchWithPayment } from 'anyspend-x402-client';
import { useWalletClient, useChainId } from 'wagmi';
import { useState } from 'react';

// 체인 ID에서 네트워크 이름을 가져오는 도우미
const getNetworkName = (chainId: number): string => {
  const networks: Record<number, string> = {
    8453: 'base',
    1: 'ethereum',
    42161: 'arbitrum',
    10: 'optimism',
    137: 'polygon',
  };
  return networks[chainId] || 'base';
};

export function PremiumDataFetcherAdvanced() {
  const { data: walletClient } = useWalletClient();
  const selectedChain = useChainId();
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [log, setLog] = useState<string[]>([]);

  // 체인별 토큰 주소
  const tokenAddresses: Record<number, string> = {
    8453: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', // Base의 DAI
    1: '0x6B175474E89094C44Da98b954EedeAC495271d0F', // 이더리움의 DAI
  };

  const fetchPremiumData = async () => {
    if (!walletClient) return;

    setLoading(true);
    setLog([]);

    try {
      const tokenAddress = tokenAddresses[selectedChain];

      const paymentPreferences = {
        preferredToken: tokenAddress,
        preferredNetwork: getNetworkName(selectedChain) as any,
      };

      setLog(prev => [...prev,
        `💡 기본 토큰 사용: ${tokenAddress} on ${getNetworkName(selectedChain)}`
      ]);

      // 자동 결제 처리를 위해 fetch를 wrap
      const fetchWithPayment = wrapFetchWithPayment(
        fetch,
        walletClient as any,
        '1000000', // 최대 1 USDC
        undefined, // 기본 결제 요구 사항 선택기 사용
        undefined, // 기본 설정 사용
        paymentPreferences,
      );

      setLog(prev => [...prev, '🔄 요청 중...']);

      const response = await fetchWithPayment('https://api.example.com/premium-data');
      const result = await response.json();

      setData(result);
      setLog(prev => [...prev, '✅ 결제 성공!']);
    } catch (error) {
      console.error('결제 실패:', error);
      setLog(prev => [...prev, `❌ 오류: ${error.message}`]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={fetchPremiumData} disabled={loading}>
        {loading ? '결제 처리 중...' : '프리미엄 데이터 가져오기'}
      </button>

      {log.length > 0 && (
        <div style={{ marginTop: '1rem', fontFamily: 'monospace' }}>
          {log.map((entry, i) => <div key={i}>{entry}</div>)}
        </div>
      )}

      {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
    </div>
  );
}
```

### Node.js 스크립트

```typescript
import { X402Client } from 'anyspend-x402-client';
import { createWalletClient, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { base } from 'viem/chains';

// 환경 변수에서 개인 키 로드
const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);

const walletClient = createWalletClient({
  account,
  chain: base,
  transport: http()
});

const x402Client = new X402Client({
  walletClient,
  preferredToken: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' // Base의 USDC
});

async function main() {
  const response = await x
