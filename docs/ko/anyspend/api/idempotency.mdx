---
title: 멱등성
description: idempotency 키를 사용한 안전한 재시도
lang: ko
originalPath: anyspend/api/idempotency.mdx
---
# 멱등성

네트워크 실패, 타임아웃, 재시도는 모든 API를 사용할 때 현실입니다. 멱등성 키는 요청을 재시도해도 중복 리소스를 생성하거나 동일한 작업을 두 번 수행하지 않도록 보장합니다.

## 작동 방식

`POST` 또는 `PATCH` 요청에 `Idempotency-Key` 헤더를 포함시키면, API는 해당 키에 대한 응답을 기억합니다. 동일한 키와 본문으로 같은 요청을 다시 보내면, API는 요청을 다시 처리하는 대신 캐시된 응답을 반환합니다.

```
POST /api/v1/payment-links
Idempotency-Key: my-unique-key-12345
Content-Type: application/json

{ "name": "Premium Plan", ... }
```

<Steps>
<Step title="첫 번째 요청">
API는 요청을 정상적으로 처리하고, 리소스를 생성한 후 응답을 캐시합니다. 응답은 멱등성 키와 요청 본문의 SHA-256 해시와 연관됩니다.
</Step>

<Step title="동일한 키 + 동일한 본문으로 재시도">
API는 중복 키를 감지하고, 본문 해시가 일치하는지 확인한 후 `Idempotent-Replayed: true` 헤더와 함께 즉시 캐시된 응답을 반환합니다. 새로운 리소스는 생성되지 않습니다.
</Step>

<Step title="동일한 키 + 다른 본문으로 재시도">
API는 중복 키를 감지하지만 본문 해시가 일치하지 않습니다. 이는 `409 Conflict` 오류와 함께 `idempotency_conflict` 코드를 반환하여 키의 잘못된 사용을 방지합니다.
</Step>
</Steps>

## 캐시 TTL

멱등성 키는 첫 번째 요청으로부터 **24시간** 동안 캐시됩니다. 24시간 후에는 키가 만료되어 재사용할 수 있습니다.

<Info>
  성공적인 응답(HTTP 2xx)만 캐시됩니다. 원래 요청이 4xx 또는 5xx 오류로 실패한 경우, 키는 사용되지 않으며 동일한 키로 재시도할 수 있습니다.
</Info>

## 멱등성 키 사용하기

### curl을 사용할 때

```bash
curl -X POST https://platform-api.anyspend.com/api/v1/payment-links \
  -H "Authorization: Bearer asp_live_abc123..." \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: create-premium-link-20240228-001" \
  -d '{
    "name": "Premium Membership",
    "amount": "10000000",
    "token_address": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "chain_id": 8453,
    "recipient_address": "0xYourAddress..."
  }'
```

첫 번째 요청에서는 표준 `201 Created` 응답을 받습니다:

```
HTTP/1.1 201 Created
Content-Type: application/json

{
  "object": "payment_link",
  "id": "pl_abc123def456",
  "name": "Premium Membership",
  ...
}
```

정확히 같은 요청을 재시도하면, 재생 헤더와 함께 캐시된 응답을 받습니다:

```
HTTP/1.1 201 Created
Content-Type: application/json
Idempotent-Replayed: true

{
  "object": "payment_link",
  "id": "pl_abc123def456",
  "name": "Premium Membership",
  ...
}
```

`id`는 동일합니다 -- 중복이 생성되지 않았습니다.

### JavaScript / TypeScript를 사용할 때

```typescript
import { randomUUID } from "crypto";

async function createPaymentLinkSafe(data: PaymentLinkInput) {
  const idempotencyKey = randomUUID();

  const makeRequest = () =>
    fetch("https://platform-api.anyspend.com/api/v1/payment-links", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.ANYSPEND_API_KEY}`,
        "Content-Type": "application/json",
        "Idempotency-Key": idempotencyKey,
      },
      body: JSON.stringify(data),
    });

  // 첫 번째 시도
  let response = await makeRequest();

  // 타임아웃이 발생하거나 네트워크 오류가 발생한 경우, 안전하게 재시도
  if (!response.ok && response.status >= 500) {
    await new Promise(resolve => setTimeout(resolve, 2000));
    response = await makeRequest(); // 동일한 멱등성 키 = 안전한 재시도
  }

  const body = await response.json();

  // 이 응답이 캐시에서 재생된 응답인지 확인
  if (response.headers.get("Idempotent-Replayed") === "true") {
    console.log("응답이 캐시에서 재생되었습니다(중복 요청).");
  }

  return body;
}
```

### Python을 사용할 때

```python
import uuid
import requests
import os

def create_payment_link_safe(data: dict) -> dict:
    idempotency_key = str(uuid.uuid4())

    headers = {
        "Authorization": f"Bearer {os.environ['ANYSPEND_API_KEY']}",
        "Content-Type": "application/json",
        "Idempotency-Key": idempotency_key,
    }

    # 동일한 멱등성 키로 최대 3번 재시도
    for attempt in range(3):
        try:
            response = requests.post(
                "https://platform-api.anyspend.com/api/v1/payment-links",
                headers=headers,
                json=data,
                timeout=10,
            )

            if response.ok:
                replayed = response.headers.get("Idempotent-Replayed") == "true"
                if replayed:
                    print("응답이 캐시에서 재생되었습니다.")
                return response.json()

            if response.status_code < 500:
                # 클라이언트 오류 -- 재시도하지 않음
                raise Exception(f"API 오류: {response.json()}")

        except requests.exceptions.Timeout:
            print(f"{attempt + 1}번째 시도가 타임아웃되었습니다, 재시도 중...")

        time.sleep(2 ** attempt)  # 지수적 백오프

    raise Exception("모든 재시도 시도가 실패했습니다")
```

## 충돌 응답

**다른** 요청 본문으로 멱등성 키를 재사용하면, API는 `409` 오류를 반환합니다:

```bash
# 원본 요청
curl -X POST https://platform-api.anyspend.com/api/v1/payment-links \
  -H "Authorization: Bearer asp_live_abc123..." \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: my-key-001" \
  -d '{ "name": "Plan A", "amount": "10000000", ... }'

# 동일한 키, 다른 본문 -- 충돌
curl -X POST https://platform-api.anyspend.com/api/v1/payment-links \
  -H "Authorization: Bearer asp_live_abc123..." \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: my-key-001" \
  -d '{ "name": "Plan B", "amount": "20000000", ... }'
```

```json
{
  "error": {
    "type": "idempotency_error",
    "code": "idempotency_conflict",
    "message": "다른 요청 본문으로 멱등성 키가 사용되었습니다."
  }
}
```

이는 안전 장치입니다. 같은 키가 실수로 두 가지 다른 작업과 연관되는 것을 방지합니다.

## 멱등성을 지원하는 메소드

| 메소드 | Idempotency-Key 지원 | 비고 |
|--------|--------------------------|-------|
| `POST` | 예 | 중복을 방지하기 위해 리소스 생성에 사용합니다. |
| `PATCH` | 예 | 동일한 업데이트를 두 번 적용하지 않도록 업데이트에 사용합니다. |
| `GET` | 필요 없음 | GET 요청은 본질적으로 멱등성이 있습니다(읽기 전용). |
| `DELETE` | 필요 없음 | DELETE 요청은 본질적으로 멱등성이 있습니다(존재하지 않는 리소스를 삭제하는 경우 404 반환). |

## 멱등성 키 생성하기

멱등성 키는 최대 256자의 문자열일 수 있습니다. 여기 몇 가지 권장 방법이 있습니다:

<Tabs>
<Tab title="UUID (권장)">
```typescript
import { randomUUID } from "crypto";

const key = randomUUID();
// "550e8400-e29b-41d4-a716-446655440000"
```

UUID는 전역적으로 고유하며 대부분의 사용 사례에 가장 간단한 옵션입니다.
</Tab>

<Tab title="결정적 키">
```typescript
// 작업 컨텍스트에서 키를 파생시킵니다
const key = `create-link-${userId}-${productId}-${Date.now()}`;
// "create-link-usr_123-prod_456-1709078400000"
```

결정적 키는 동일한 논리적 작업이 항상 동일한 키를 사용하도록 하고 싶을 때 유용합니다 -- 예를 들어, 특정 제품에 대해 사용자가 하나의 결제 링크만 생성할 수 있도록 하는 경우입니다.
</Tab>

<Tab title="요청 해시">
```typescript
import { createHash } from "crypto";

const key = createHash("sha256")
  .update(JSON.stringify({ endpoint: "/payment-links", body: data }))
  .digest("hex")
  .slice(0, 64);
```

요청을 해싱하면 동일한 요청이 항상 동일한 키를 생성합니다. 동일한 메시지가 여러 번 처리될 수 있는 큐 기반 시스템에 유용합니다.
</Tab>
</Tabs>

## 멱등성 키 범위

멱등성 키는 **조직**에 범위가 지정됩니다. 두 개의 다른 조직은 동일한 키 문자열을 충돌 없이 사용할 수 있습니다. 조직 내에서는 각 키를 24시간 창에서 한 번만 사용할 수 있습니다.

## 모범 사례

<AccordionGroup>
<Accordion title="결제 관련 작업에는 항상 멱등성 키를 사용하세요">
결제 링크를 생성하거나, 체크아웃 세션을 시작하거나, 금융 조치를 촉발하는 모든 요청에는 멱등성 키를 포함해야 합니다. 이것이 중복을 방지하는 가장 중요한 장소입니다.
</Accordion>

<Accordion title="첫 시도 전에 키를 생성하세요">
멱등성 키를 한 번 생성하고 동일한 논리적 작업에 대한 모든 재시도에 걸쳐 재사용하세요:

```typescript
// 올바름: 키를 한 번 생성하고 재시도에 재사용
const key = randomUUID();
for (let attempt = 0; attempt < 3; attempt++) {
  const response = await fetch(url, {
    headers: { "Idempotency-Key": key },
    body: JSON.stringify(data),
  });
  if (response.ok) break;
}

// 잘못됨: 각 재시도마다 새로운 키 (목적을 무시함)
for (let attempt = 0; attempt < 3; attempt++) {
  const response = await fetch(url, {
    headers: { "Idempotency-Key": randomUUID() }, // 매번 다른 키!
    body: JSON.stringify(data),
  });
  if (response.ok) break;
}
```
</Accordion>

<Accordion title="다른 작업에 대해 키를 재사용하지 마세요">
각 논리적 작업은 자체 멱등성 키를 가져야 합니다. 이전 작업(다른 작업)에서 사용된 키를 재사용하면 이전 작업의 캐시된 응답이나 `409` 충돌 중 하나가 발생합니다.
</Accordion>

<Accordion title="409 충돌을 우아하게 처리하세요">
`idempotency_conflict` 오류를 받으면 키가 다른 요청 본문과 이미 사용되었다는 의미입니다. 새 키를 생성하고 재시도하세요:

```typescript
if (error.code === "idempotency_conflict") {
  // 새로운 키를 생성하고 재시도
  return createPaymentLink(data, { idempotencyKey: randomUUID() });
}
```
</Accordion>

<Accordion title="Idempotent-Replayed 헤더를 확인하세요">
`Idempotent-Replayed: true` 헤더가 존재하면 응답이 캐시에서 재생된 것입니다. 이는 로깅 및 디버깅에 유용할 수 있어, 신선한 응답과 재생된 응답을 구별할 수 있습니다.
</Accordion>

<Accordion title="정확히 한 번의 의미를 위해 결정적 키를 사용하세요">
시스템이 큐에서 이벤트를 처리하는 경우(예: Kafka, SQS, BullMQ), 이벤트 ID 또는 메시지 ID에서 멱등성 키를 파생시킵니다. 이를 통해 동일한 이벤트를 두 번 처리해도 중복 리소스가 생성되지 않도록 보장합니다:

```typescript
async function handleOrderEvent(event: QueueEvent) {
  const idempotencyKey = `order-event-${event.messageId}`;

  await fetch("https://platform-api.anyspend.com/api/v1/payment-links", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${process.env.ANYSPEND_API_KEY}`,
      "Content-Type": "application/json",
      "Idempotency-Key": idempotencyKey,
    },
    body: JSON.stringify(eventToPaymentLink(event)),
  });
}
```
</Accordion>
</AccordionGroup>
