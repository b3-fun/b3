---
title: Cunhagem
description: >-
  Guia completo para cunhagem de tokens com CreateKit incluindo implanta√ß√£o,
  cunhagem regular e recursos avan√ßados
lang: pt-BR
originalPath: createkit/minting.mdx
---
## Vis√£o Geral

Cunhagem √© o processo de criar novos tokens NFT dentro da sua cole√ß√£o. O CreateKit oferece um sistema de cunhagem em duas fases √∫nico que otimiza a efici√™ncia de g√°s e a experi√™ncia do usu√°rio.

## Fases da Cunhagem

### Fase 1: Implanta√ß√£o & Primeira Cunhagem

A primeira opera√ß√£o de cunhagem √© especial - ela implanta o contrato da cole√ß√£o e cunha o primeiro token em uma √∫nica transa√ß√£o:

```typescript title="Implanta√ß√£o e Primeira Cunhagem"
import { CollectionManager } from '@b3dotfun/basemint'

const collectionManager = new CollectionManager(publicClient)

// Suponha que temos metadados da cole√ß√£o e assinatura do criador
const predictedAddress = collectionManager.predictCollectionAddress(
  collectionMetadata,
  creatorSignature
)

// Gerar assinatura do implantador
const deployerSignature = await collectionManager.generateDeployerSignature(
  walletClient,
  predictedAddress
)

// Criar inst√¢ncia da cole√ß√£o
const collection = collectionManager.createCollection(
  predictedAddress,
  collectionMetadata.tokenStandard
)

// Implantar e cunhar o primeiro NFT
const mintTx = await collection.mint(
  walletClient,
  1n, // quantidade
  undefined, // URI dos metadados (usa baseURI)
  collectionMetadata.mintPrice || 0n,
  [], // prova da lista branca (vazia para p√∫blico)
  creatorSignature, // Necess√°rio para a primeira cunhagem
  deployerSignature // Necess√°rio para a primeira cunhagem
)

console.log(`üöÄ Cole√ß√£o implantada e primeiro token cunhado: ${mintTx}`)
```

### Fase 2: Cunhagem Regular

Ap√≥s a implanta√ß√£o, as cunhagens subsequentes s√£o mais simples e s√≥ requerem os par√¢metros padr√£o:

```typescript title="Cunhagem Regular"
// Para cunhagens subsequentes (ap√≥s a implanta√ß√£o)
const regularMintTx = await collection.mint(
  walletClient,
  1n, // quantidade
  undefined, // URI dos metadados
  collectionMetadata.mintPrice || 0n,
  [] // prova da lista branca
  // Nenhuma assinatura necess√°ria para cunhagens regulares
)

console.log(`‚ú® Token cunhado: ${regularMintTx}`)
```

## Padr√µes de Token

O CreateKit suporta tanto os padr√µes ERC721 quanto ERC1155 com comportamentos de cunhagem diferentes:

<Tabs>
<Tab title="Cunhagem ERC721">
```typescript title="Tokens √önicos ERC721"
// ERC721 - Cada token √© √∫nico
const erc721Collection = collectionManager.createCollection(
  predictedAddress,
  "ERC721"
)

// ERC721 sempre cunha quantidade de 1
await erc721Collection.mint(
  walletClient,
  1n, // Sempre 1 para ERC721
  "https://example.com/metadata/1.json", // Metadados √∫nicos para este token
  parseEther("0.01"),
  []
)

// Cada cunhagem cria um novo ID de token √∫nico
// IDs de token incrementam: 1, 2, 3, etc.
```
</Tab>

<Tab title="Cunhagem ERC1155">
```typescript title="Tokens Semi-Fung√≠veis ERC1155"
// ERC1155 - Pode cunhar m√∫ltiplos do mesmo ou diferentes tokens
const erc1155Collection = collectionManager.createCollection(
  predictedAddress,
  "ERC1155"
)

// Pode cunhar m√∫ltiplos tokens do mesmo tipo
await erc1155Collection.mint(
  walletClient,
  10n, // Cunhar 10 tokens
  "https://example.com/metadata/sword.json", // Metadados para tokens "espada"
  parseEther("0.005"),
  []
)

// Pode cunhar diferentes tipos de token mudando o URI dos metadados
await erc1155Collection.mint(
  walletClient,
  5n,
  "https://example.com/metadata/shield.json", // Diferente tipo de token
  parseEther("0.01"),
  []
)
```
</Tab>
</Tabs>

## Pre√ßos e Pagamento

### Pre√ßos Fixos

```typescript title="Cunhagem com Pre√ßo Fixo"
import { parseEther } from 'viem'

const fixedPriceCollection = {
  name: "Cole√ß√£o de Pre√ßo Fixo",
  symbol: "FPC",
  creator: account.address,
  gameOwner: account.address,
  mintPrice: parseEther("0.01"), // 0.01 ETH por token
  maxPerWallet: 5n
}

// Cunhar com pre√ßo fixo
await collection.mint(
  walletClient,
  2n, // quantidade
  undefined,
  parseEther("0.02"), // 2 * 0.01 ETH
  []
)
```

### Cunhagem Gratuita

```typescript title="Cunhagem Gratuita"
const freeCollection = {
  name: "Cole√ß√£o Gratuita",
  symbol: "FREE",
  creator: account.address,
  gameOwner: account.address,
  mintPrice: 0n, // Cunhagem gratuita
  maxPerWallet: 10n
}

// Cunhar de gra√ßa (apenas custos de g√°s)
await collection.mint(
  walletClient,
  1n,
  undefined,
  0n, // Sem pagamento necess√°rio
  []
)
```

### Pre√ßos Din√¢micos

```typescript title="L√≥gica de Pre√ßos Din√¢micos"
// L√≥gica de pre√ßos personalizada na sua aplica√ß√£o
function calculateMintPrice(totalSupply: bigint, basePrice: bigint): bigint {
  // O pre√ßo aumenta com a oferta
  const priceMultiplier = totalSupply / 1000n + 1n
  return basePrice * priceMultiplier
}

// Obter oferta atual e calcular pre√ßo
const currentSupply = await collection.totalSupply()
const dynamicPrice = calculateMintPrice(currentSupply, parseEther("0.001"))

await collection.mint(
  walletClient,
  1n,
  undefined,
  dynamicPrice,
  []
)
```

## Cunhagem com Lista Branca

O CreateKit suporta listas brancas baseadas em √°rvore de Merkle para cunhagem exclusiva:

### Configurando Lista Branca

```typescript title="Configura√ß√£o da Lista Branca"
import { WhitelistManager } from '@b3dotfun/basemint'

// Criar lista branca com endere√ßos
const whitelist = new WhitelistManager([
  { address: "0x1234567890123456789012345678901234567890" },
  { address: "0x2345678901234567890123456789012345678901" },
  { address: "0x3456789012345678901234567890123456789012" }
])

// Obter raiz da Merkle para implanta√ß√£o da cole√ß√£o
const merkleRoot = whitelist.getRoot()

const whitelistCollection = {
  name: "Cole√ß√£o Lista Branca",
  symbol: "WLC",
  creator: account.address,
  gameOwner: account.address,
  isWhitelistEnabled: true,
  whitelistMerkleRoot: merkleRoot,
  mintPrice: parseEther("0.005")
}
```

### Cunhagem com Prova de Lista Branca

```typescript title="Cunhagem com Prova de Lista Branca"
// Obter prova para o endere√ßo de cunhagem
const userAddress = account.address
const proof = whitelist.getProof(userAddress)

// Verificar se o usu√°rio est√° na lista branca (checagem opcional)
const isWhitelisted = whitelist.verify(userAddress, proof)
if (!isWhitelisted) {
  throw new Error("Endere√ßo n√£o est√° na lista branca")
}

// Cunhar com prova de lista branca
await collection.mint(
  walletClient,
  1n,
  undefined,
  parseEther("0.005"),
  proof // Fornecer prova de lista branca
)
```

## Limites e Controles de Cunhagem

### Limites por Carteira

```typescript title="Limites da Carteira"
// Definir tokens m√°ximos por carteira
const limitedCollection = {
  name: "Cole√ß√£o Limitada",
  symbol: "LTD",
  creator: account.address,
  gameOwner: account.address,
  maxPerWallet: 3n, // M√°ximo de 3 tokens por carteira
  maxSupply: 1000n
}

// Verificar saldo atual antes de cunhar
const currentBalance = await collection.balanceOf(account.address)
const maxPerWallet = await collection.maxPerWallet()

if (currentBalance >= maxPerWallet) {
  throw new Error("Limite da carteira excedido")
}

await collection.mint(walletClient, 1n, undefined, 0n, [])
```

### Controles Baseados em Tempo

```typescript title="Controles de Tempo"
const timedCollection = {
  name: "Lan√ßamento Programado",
  symbol: "TIME",
  creator: account.address,
  gameOwner: account.address,
  startTime: BigInt(Math.floor(Date.now() / 1000) + 3600), // Come√ßa em 1 hora
  endTime: BigInt(Math.floor(Date.now() / 1000) + 86400), // Termina em 24 horas
}

// Verificar se a cunhagem est√° ativa no momento
const currentTime = BigInt(Math.floor(Date.now() / 1000))
const startTime = await collection.startTime()
const endTime = await collection.endTime()

const isMintingActive = currentTime >= startTime && currentTime <= endTime

if (!isMintingActive) {
  throw new Error("Cunhagem n√£o est√° ativa no momento")
}
```

## Manipula√ß√£o de Metadados

### Metadados Autom√°ticos

O CreateKit pode gerar automaticamente metadados com base nas configura√ß√µes da cole√ß√£o:

```typescript title="Metadados Gerados Automaticamente"
// Usando baseURI para metadados autom√°ticos
const autoMetadataCollection = {
  name: "Cole√ß√£o de Metadados Autom√°ticos",
  symbol: "AMC",
  creator: account.address,
  gameOwner: account.address,
  // baseURI ser√° gerado automaticamente pelo CDN do BaseMint
}

// Cunhar com metadados autom√°ticos (passar undefined para URI)
await collection.mint(
  walletClient,
  1n,
  undefined, // Usa baseURI + tokenId
  0n,
  []
)

// Metadados estar√£o dispon√≠veis em: {baseURI}/{tokenId}
```

### Metadados Personalizados

```typescript title="URIs de Metadados Personalizados"
// Fornecer URI de metadados espec√≠ficos para cada token
const customMetadataURIs = [
  "https://myapi.com/metadata/special-sword.json",
  "https://myapi.com/metadata/rare-shield.json",
  "https://myapi.com/metadata/epic-helmet.json"
]

for (const metadataURI of customMetadataURIs) {
  await collection.mint(
    walletClient,
    1n,
    metadataURI, // Metadados personalizados para este token
    parseEther("0.01"),
    []
  )
}
```

## Cunhagem em Lote

Para cole√ß√µes ERC1155, voc√™ pode cunhar m√∫ltiplos tokens de forma eficiente:

```typescript title="Cunhagem em Lote"
// √önica transa√ß√£o, m√∫ltiplos tokens
await erc1155Collection.mint(
  walletClient,
  10n, // Cunhar 10 tokens do mesmo tipo
  "https://example.com/metadata/resource.json",
  parseEther("0.001") * 10n, // Pre√ßo total para todos os tokens
  []
)

// Para diferentes tipos de token, use transa√ß√µes separadas
const tokenTypes = [
  { uri: "https://example.com/wood.json", quantity: 5n },
  { uri: "https://example.com/stone.json", quantity: 3n },
  { uri: "https://example.com/gold.json", quantity: 1n }
]

for (const tokenType of tokenTypes) {
  await erc1155Collection.mint(
    walletClient,
    tokenType.quantity,
    tokenType.uri,
    calculatePrice(tokenType.quantity),
    []
  )
}
```

## Tratamento de Erros

```typescript title="Tratamento Abrangente de Erros"
async function safeMint(
  collection: any,
  walletClient: any,
  quantity: bigint,
  metadataURI: string | undefined,
  mintPrice: bigint,
  proof: string[]
) {
  try {
    // Valida√ß√µes pr√©-cunhagem
    const isDeployed = await collection.isDeployed()
    if (!isDeployed) {
      throw new Error("Cole√ß√£o ainda n√£o implantada")
    }

    const currentSupply = await collection.totalSupply()
    const maxSupply = await collection.maxSupply()
    if (currentSupply + quantity > maxSupply) {
      throw new Error("Ultrapassaria o m√°ximo de oferta")
    }

    const userBalance = await collection.balanceOf(walletClient.account.address)
    const maxPerWallet = await collection.maxPerWallet()
    if (userBalance + quantity > maxPerWallet) {
      throw new Error("Ultrapassaria o limite da carteira")
    }

    // Verificar quantidade de pagamento
    const requiredPayment = await collection.mintPrice() * quantity
    if (mintPrice < requiredPayment) {
      throw new Error("Pagamento insuficiente")
    }

    // Tentar cunhar
    const tx = await collection.mint(
      walletClient,
      quantity,
      metadataURI,
      mintPrice,
      proof
    )

    console.log(`‚úÖ Cunhagem bem-sucedida: ${tx}`)
    return tx

  } catch (error: any) {
    if (error.message.includes('Invalid merkle proof')) {
      console.error('‚ùå Endere√ßo n√£o est√° na lista branca')
    } else if (error.message.includes('Pagamento insuficiente')) {
      console.error('‚ùå Pre√ßo de cunhagem incorreto')
    } else if (error.message.includes('Limite por carteira excedido')) {
      console.error('‚ùå Limite da carteira atingido')
    } else {
      console.error('‚ùå Cunhagem falhou:', error.message)
    }
    throw error
  }
}
```

## Otimiza√ß√£o de G√°s

### Padr√µes de Cunhagem Eficientes

```typescript title="Cunhagem Eficiente de G√°s"
// Para ERC1155: Cunhar m√∫ltiplos tokens em uma transa√ß√£o
await erc1155Collection.mint(
  walletClient,
  10n, // Mais eficiente em g√°s do que 10 transa√ß√µes separadas
  metadataURI,
  totalPrice,
  proof
)

// Para ERC721: Considere opera√ß√µes em lote no n√≠vel da aplica√ß√£o
const mintPromises = []
for (let i = 0; i < 5; i++) {
  mintPromises.push(
    collection.mint(walletClient, 1n, undefined, mintPrice, proof)
  )
}

// Executar cunhagens simultaneamente (cuidado com o gerenciamento de nonce)
const results = await Promise.all(mintPromises)
```

### Gerenciamento do Pre√ßo do G√°s

```typescript title="Otimiza√ß√£o do Pre√ßo do G√°s"
import { createWalletClient, http } from 'viem'

// Configura√ß√£o de g√°s personalizada
const optimizedWalletClient = createWalletClient({
  chain: b3Testnet,
  transport: http(),
  account,
  // Configura√ß√£o de g√°s
  gasPrice: parseGwei('20'), // Pre√ßo de g√°s personalizado
})

// Ou use precifica√ß√£o de g√°s din√¢mica
const gasPrice = await publicClient.getGasPrice()
const adjustedGasPrice = gasPrice * 110n / 100n // 10% acima do pre√ßo atual

await collection.mint(
  optimizedWalletClient,
  1n,
  undefined,
  mintPrice,
  proof,
  {
    gasPrice: adjustedGasPrice
  }
)
```

## Monitoramento e An√°lise

### Rastreamento de Eventos de Cunhagem

```typescript title="Monitoramento de Eventos"
import { getCollectionMintEvents } from '@b3dotfun/basemint'

// Rastrear eventos de cunhagem
const fromBlock = await publicClient.getBlockNumber() - 1000n
const toBlock = await publicClient.getBlockNumber()

const mintEvents = await getCollectionMintEvents(
  publicClient,
  collection.address,
  "ERC721",
  fromBlock,
  toBlock
)

console.log("Cunhagens recentes:", mintEvents.map(event => ({
  minter: event.args.minter,
  tokenId: event.args.tokenId?.toString(),
  quantity: event.args.quantity?.toString(),
  blockNumber: event.blockNumber
})))
```

### Monitoramento em Tempo Real

```typescript title="Monitoramento de Cunhagem em Tempo Real"
// Observar novos eventos de cunhagem
const unwatch = publicClient.watchContractEvent({
  address: collection.address,
  abi: collection.abi,
  eventName: 'Transfer', // ou 'TransferSingle' para ERC1155
  onLogs: (logs) => {
    logs.forEach(log => {
      console.log('Nova cunhagem detectada:', {
        from: log.args.from,
        to: log.args.to,
        tokenId: log.args.tokenId?.toString()
      })
    })
  }
})

// Parar de observar quando terminar
// unwatch()
```

## Melhores Pr√°ticas

<CardGroup cols={2}>
  <Card title="Experi√™ncia do Usu√°rio" icon="user">
    - Fornecer feedback claro durante o processo de cunhagem
    - Mostrar custos estimados de g√°s antecipadamente
    - Implementar estados de carregamento adequados
    - Tratar erros de forma graciosa com mensagens amig√°veis ao usu√°rio
  </Card>
  <Card title="Intera√ß√£o com Contrato Inteligente" icon="code">
    - Sempre validar par√¢metros antes das transa√ß√µes
    - Implementar tratamento de erros adequado
    - Usar limites e pre√ßos de g√°s apropriados
    - Aguardar confirma√ß√µes de transa√ß√£o
  </Card>
</CardGroup>
