---
title: Acu√±aci√≥n
description: >-
  Gu√≠a completa para la acu√±aci√≥n de tokens con CreateKit incluyendo la
  implementaci√≥n, acu√±aci√≥n regular y caracter√≠sticas avanzadas
lang: es
originalPath: createkit/minting.mdx
---

## Visi√≥n general

La acu√±aci√≥n es el proceso de crear nuevos tokens NFT dentro de tu colecci√≥n. CreateKit proporciona un sistema de acu√±aci√≥n en dos fases √∫nico que optimiza la eficiencia del gas y la experiencia del usuario.

## Fases de Acu√±aci√≥n

### Fase 1: Despliegue y Primera Acu√±aci√≥n

La primera operaci√≥n de acu√±aci√≥n es especial: despliega el contrato de la colecci√≥n y acu√±a el primer token en una sola transacci√≥n:

```typescript title="Despliegue y Primera Acu√±aci√≥n"
import { CollectionManager } from "@b3dotfun/basemint";

const collectionManager = new CollectionManager(publicClient);

// Supongamos que tenemos metadatos de la colecci√≥n y firma del creador
const predictedAddress = collectionManager.predictCollectionAddress(collectionMetadata, creatorSignature);

// Generar firma del desplegador
const deployerSignature = await collectionManager.generateDeployerSignature(walletClient, predictedAddress);

// Crear instancia de la colecci√≥n
const collection = collectionManager.createCollection(predictedAddress, collectionMetadata.tokenStandard);

// Desplegar y acu√±ar el primer NFT
const mintTx = await collection.mint(
  walletClient,
  1n, // cantidad
  undefined, // URI de metadatos (usa baseURI)
  collectionMetadata.mintPrice || 0n,
  [], // prueba de lista blanca (vac√≠a para p√∫blico)
  creatorSignature, // Requerido para la primera acu√±aci√≥n
  deployerSignature, // Requerido para la primera acu√±aci√≥n
);

console.log(`üöÄ Colecci√≥n desplegada y primer token acu√±ado: ${mintTx}`);
```

### Fase 2: Acu√±aci√≥n Regular

Despu√©s del despliegue, las acu√±aciones subsiguientes son m√°s simples y solo requieren los par√°metros est√°ndar:

```typescript title="Acu√±aci√≥n Regular"
// Para acu√±aciones subsiguientes (despu√©s del despliegue)
const regularMintTx = await collection.mint(
  walletClient,
  1n, // cantidad
  undefined, // URI de metadatos
  collectionMetadata.mintPrice || 0n,
  [], // prueba de lista blanca
  // No se necesitan firmas para acu√±aciones regulares
);

console.log(`‚ú® Token acu√±ado: ${regularMintTx}`);
```

## Est√°ndares de Token

CreateKit soporta tanto los est√°ndares ERC721 como ERC1155 con diferentes comportamientos de acu√±aci√≥n:

<Tabs>
<Tab title="Acu√±aci√≥n ERC721">
```typescript title="Tokens √önicos ERC721"
// ERC721 - Cada token es √∫nico
const erc721Collection = collectionManager.createCollection(
  predictedAddress,
  "ERC721"
)

// ERC721 siempre acu√±a cantidad de 1
await erc721Collection.mint(
walletClient,
1n, // Siempre 1 para ERC721
"https://example.com/metadata/1.json", // Metadatos √∫nicos para este token
parseEther("0.01"),
[]
)

// Cada acu√±aci√≥n crea un nuevo ID de token √∫nico
// Los IDs de token incrementan: 1, 2, 3, etc.

````
</Tab>

<Tab title="Acu√±aci√≥n ERC1155">
```typescript title="Tokens Semi-Fungibles ERC1155"
// ERC1155 - Puede acu√±ar m√∫ltiples del mismo o diferentes tokens
const erc1155Collection = collectionManager.createCollection(
  predictedAddress,
  "ERC1155"
)

// Puede acu√±ar m√∫ltiples tokens del mismo tipo
await erc1155Collection.mint(
  walletClient,
  10n, // Acu√±ar 10 tokens
  "https://example.com/metadata/sword.json", // Metadatos para tokens "espada"
  parseEther("0.005"),
  []
)

// Puede acu√±ar diferentes tipos de tokens cambiando el URI de metadatos
await erc1155Collection.mint(
  walletClient,
  5n,
  "https://example.com/metadata/shield.json", // Diferente tipo de token
  parseEther("0.01"),
  []
)
````

</Tab>
</Tabs>

## Precios y Pagos

### Precios Fijos

```typescript title="Acu√±aci√≥n a Precio Fijo"
import { parseEther } from "viem";

const fixedPriceCollection = {
  name: "Colecci√≥n a Precio Fijo",
  symbol: "FPC",
  creator: account.address,
  gameOwner: account.address,
  mintPrice: parseEther("0.01"), // 0.01 ETH por token
  maxPerWallet: 5n,
};

// Acu√±ar con precio fijo
await collection.mint(
  walletClient,
  2n, // cantidad
  undefined,
  parseEther("0.02"), // 2 * 0.01 ETH
  [],
);
```

### Acu√±aci√≥n Gratuita

```typescript title="Acu√±aci√≥n Gratuita"
const freeCollection = {
  name: "Colecci√≥n Gratuita",
  symbol: "FREE",
  creator: account.address,
  gameOwner: account.address,
  mintPrice: 0n, // Acu√±aci√≥n gratuita
  maxPerWallet: 10n,
};

// Acu√±ar gratis (solo costos de gas)
await collection.mint(
  walletClient,
  1n,
  undefined,
  0n, // No se requiere pago
  [],
);
```

### Precios Din√°micos

```typescript title="L√≥gica de Precios Din√°micos"
// L√≥gica de precios personalizada en tu aplicaci√≥n
function calculateMintPrice(totalSupply: bigint, basePrice: bigint): bigint {
  // El precio aumenta con la oferta
  const priceMultiplier = totalSupply / 1000n + 1n;
  return basePrice * priceMultiplier;
}

// Obtener oferta actual y calcular precio
const currentSupply = await collection.totalSupply();
const dynamicPrice = calculateMintPrice(currentSupply, parseEther("0.001"));

await collection.mint(walletClient, 1n, undefined, dynamicPrice, []);
```

## Acu√±aci√≥n con Lista Blanca

CreateKit soporta listas blancas basadas en √°rboles de Merkle para acu√±aciones exclusivas:

### Configuraci√≥n de Lista Blanca

```typescript title="Configuraci√≥n de Lista Blanca"
import { WhitelistManager } from "@b3dotfun/basemint";

// Crear lista blanca con direcciones
const whitelist = new WhitelistManager([
  { address: "0x1234567890123456789012345678901234567890" },
  { address: "0x2345678901234567890123456789012345678901" },
  { address: "0x3456789012345678901234567890123456789012" },
]);

// Obtener ra√≠z de Merkle para el despliegue de la colecci√≥n
const merkleRoot = whitelist.getRoot();

const whitelistCollection = {
  name: "Colecci√≥n con Lista Blanca",
  symbol: "WLC",
  creator: account.address,
  gameOwner: account.address,
  isWhitelistEnabled: true,
  whitelistMerkleRoot: merkleRoot,
  mintPrice: parseEther("0.005"),
};
```

### Acu√±aci√≥n con Prueba de Lista Blanca

```typescript title="Acu√±aci√≥n con Prueba de Lista Blanca"
// Obtener prueba para la direcci√≥n de acu√±aci√≥n
const userAddress = account.address;
const proof = whitelist.getProof(userAddress);

// Verificar que el usuario est√° en la lista blanca (verificaci√≥n opcional)
const isWhitelisted = whitelist.verify(userAddress, proof);
if (!isWhitelisted) {
  throw new Error("Direcci√≥n no est√° en la lista blanca");
}

// Acu√±ar con prueba de lista blanca
await collection.mint(
  walletClient,
  1n,
  undefined,
  parseEther("0.005"),
  proof, // Proporcionar prueba de lista blanca
);
```

## L√≠mites y Controles de Acu√±aci√≥n

### L√≠mites por Cartera

```typescript title="L√≠mites de Cartera"
// Establecer tokens m√°ximos por cartera
const limitedCollection = {
  name: "Colecci√≥n Limitada",
  symbol: "LTD",
  creator: account.address,
  gameOwner: account.address,
  maxPerWallet: 3n, // M√°ximo 3 tokens por cartera
  maxSupply: 1000n,
};

// Verificar saldo actual antes de acu√±ar
const currentBalance = await collection.balanceOf(account.address);
const maxPerWallet = await collection.maxPerWallet();

if (currentBalance >= maxPerWallet) {
  throw new Error("L√≠mite de cartera excedido");
}

await collection.mint(walletClient, 1n, undefined, 0n, []);
```

### Controles Basados en Tiempo

```typescript title="Controles de Tiempo"
const timedCollection = {
  name: "Lanzamiento Programado",
  symbol: "TIME",
  creator: account.address,
  gameOwner: account.address,
  startTime: BigInt(Math.floor(Date.now() / 1000) + 3600), // Comienza en 1 hora
  endTime: BigInt(Math.floor(Date.now() / 1000) + 86400), // Termina en 24 horas
};

// Verificar si la acu√±aci√≥n est√° activa actualmente
const currentTime = BigInt(Math.floor(Date.now() / 1000));
const startTime = await collection.startTime();
const endTime = await collection.endTime();

const isMintingActive = currentTime >= startTime && currentTime <= endTime;

if (!isMintingActive) {
  throw new Error("Acu√±aci√≥n no activa actualmente");
}
```

## Manejo de Metadatos

### Metadatos Autom√°ticos

CreateKit puede generar autom√°ticamente metadatos basados en la configuraci√≥n de la colecci√≥n:

```typescript title="Metadatos Auto-Generados"
// Usando baseURI para metadatos autom√°ticos
const autoMetadataCollection = {
  name: "Colecci√≥n de Metadatos Autom√°ticos",
  symbol: "AMC",
  creator: account.address,
  gameOwner: account.address,
  // baseURI ser√° generado autom√°ticamente por BaseMint CDN
};

// Acu√±ar con metadatos autom√°ticos (pasar undefined para URI)
await collection.mint(
  walletClient,
  1n,
  undefined, // Usa baseURI + tokenId
  0n,
  [],
);

// Los metadatos estar√°n disponibles en: {baseURI}/{tokenId}
```

### Metadatos Personalizados

```typescript title="URIs de Metadatos Personalizados"
// Proporcionar URI de metadatos espec√≠ficos para cada token
const customMetadataURIs = [
  "https://myapi.com/metadata/special-sword.json",
  "https://myapi.com/metadata/rare-shield.json",
  "https://myapi.com/metadata/epic-helmet.json",
];

for (const metadataURI of customMetadataURIs) {
  await collection.mint(
    walletClient,
    1n,
    metadataURI, // Metadatos personalizados para este token
    parseEther("0.01"),
    [],
  );
}
```

## Acu√±aci√≥n por Lotes

Para colecciones ERC1155, puedes acu√±ar m√∫ltiples tokens de manera eficiente:

```typescript title="Acu√±aci√≥n por Lotes"
// Una transacci√≥n, m√∫ltiples tokens
await erc1155Collection.mint(
  walletClient,
  10n, // Acu√±ar 10 tokens del mismo tipo
  "https://example.com/metadata/resource.json",
  parseEther("0.001") * 10n, // Precio total por todos los tokens
  [],
);

// Para diferentes tipos de tokens, usa transacciones separadas
const tokenTypes = [
  { uri: "https://example.com/wood.json", quantity: 5n },
  { uri: "https://example.com/stone.json", quantity: 3n },
  { uri: "https://example.com/gold.json", quantity: 1n },
];

for (const tokenType of tokenTypes) {
  await erc1155Collection.mint(walletClient, tokenType.quantity, tokenType.uri, calculatePrice(tokenType.quantity), []);
}
```

## Manejo de Errores

```typescript title="Manejo de Errores Integral"
async function safeMint(
  collection: any,
  walletClient: any,
  quantity: bigint,
  metadataURI: string | undefined,
  mintPrice: bigint,
  proof: string[],
) {
  try {
    // Validaciones previas a la acu√±aci√≥n
    const isDeployed = await collection.isDeployed();
    if (!isDeployed) {
      throw new Error("Colecci√≥n a√∫n no desplegada");
    }

    const currentSupply = await collection.totalSupply();
    const maxSupply = await collection.maxSupply();
    if (currentSupply + quantity > maxSupply) {
      throw new Error("Se superar√≠a el m√°ximo de suministro");
    }

    const userBalance = await collection.balanceOf(walletClient.account.address);
    const maxPerWallet = await collection.maxPerWallet();
    if (userBalance + quantity > maxPerWallet) {
      throw new Error("Se superar√≠a el l√≠mite de la cartera");
    }

    // Verificar cantidad de pago
    const requiredPayment = (await collection.mintPrice()) * quantity;
    if (mintPrice < requiredPayment) {
      throw new Error("Pago insuficiente");
    }

    // Intentar acu√±ar
    const tx = await collection.mint(walletClient, quantity, metadataURI, mintPrice, proof);

    console.log(`‚úÖ Acu√±aci√≥n exitosa: ${tx}`);
    return tx;
  } catch (error: any) {
    if (error.message.includes("Invalid merkle proof")) {
      console.error("‚ùå Direcci√≥n no en lista blanca");
    } else if (error.message.includes("Insufficient payment")) {
      console.error("‚ùå Precio de acu√±aci√≥n incorrecto");
    } else if (error.message.includes("Max per wallet exceeded")) {
      console.error("‚ùå L√≠mite de cartera alcanzado");
    } else {
      console.error("‚ùå Acu√±aci√≥n fallida:", error.message);
    }
    throw error;
  }
}
```

## Optimizaci√≥n de Gas

### Patrones de Acu√±aci√≥n Eficientes

```typescript title="Acu√±aci√≥n Eficiente de Gas"
// Para ERC1155: Acu√±ar m√∫ltiples tokens en una transacci√≥n
await erc1155Collection.mint(
  walletClient,
  10n, // M√°s eficiente en gas que 10 transacciones separadas
  metadataURI,
  totalPrice,
  proof,
);

// Para ERC721: Considerar operaciones por lotes a nivel de aplicaci√≥n
const mintPromises = [];
for (let i = 0; i < 5; i++) {
  mintPromises.push(collection.mint(walletClient, 1n, undefined, mintPrice, proof));
}

// Ejecutar acu√±aciones concurrentemente (tener cuidado con la gesti√≥n de nonce)
const results = await Promise.all(mintPromises);
```

### Gesti√≥n del Precio del Gas

```typescript title="Optimizaci√≥n del Precio del Gas"
import { createWalletClient, http } from "viem";

// Configuraci√≥n de gas personalizada
const optimizedWalletClient = createWalletClient({
  chain: b3Testnet,
  transport: http(),
  account,
  // Configuraci√≥n de gas
  gasPrice: parseGwei("20"), // Precio de gas personalizado
});

// O usar precios de gas din√°micos
const gasPrice = await publicClient.getGasPrice();
const adjustedGasPrice = (gasPrice * 110n) / 100n; // 10% por encima del precio actual

await collection.mint(optimizedWalletClient, 1n, undefined, mintPrice, proof, {
  gasPrice: adjustedGasPrice,
});
```

## Monitoreo y An√°lisis

### Seguimiento de Eventos de Acu√±aci√≥n

```typescript title="Monitoreo de Eventos"
import { getCollectionMintEvents } from "@b3dotfun/basemint";

// Seguir eventos de acu√±aci√≥n
const fromBlock = (await publicClient.getBlockNumber()) - 1000n;
const toBlock = await publicClient.getBlockNumber();

const mintEvents = await getCollectionMintEvents(publicClient, collection.address, "ERC721", fromBlock, toBlock);

console.log(
  "Acu√±aciones recientes:",
  mintEvents.map(event => ({
    minter: event.args.minter,
    tokenId: event.args.tokenId?.toString(),
    quantity: event.args.quantity?.toString(),
    blockNumber: event.blockNumber,
  })),
);
```

### Monitoreo en Tiempo Real

```typescript title="Monitoreo de Acu√±aciones en Tiempo Real"
// Observar nuevos eventos de acu√±aci√≥n
const unwatch = publicClient.watchContractEvent({
  address: collection.address,
  abi: collection.abi,
  eventName: "Transfer", // o 'TransferSingle' para ERC1155
  onLogs: logs => {
    logs.forEach(log => {
      console.log("Nueva acu√±aci√≥n detectada:", {
        from: log.args.from,
        to: log.args.to,
        tokenId: log.args.tokenId?.toString(),
      });
    });
  },
});

// Detener la observaci√≥n cuando se termine
// unwatch()
```

## Mejores Pr√°cticas

<CardGroup cols={2}>
  <Card title="Experiencia del Usuario" icon="user">
    - Proporcionar retroalimentaci√≥n clara durante el proceso de acu√±aci√≥n - Mostrar costos estimados de gas por
    adelantado - Implementar estados de carga adecuados - Manejar errores de manera amigable para el usuario
  </Card>
  <Card title="Interacci√≥n con Contratos Inteligentes" icon="code">
    - Validar siempre los par√°metros antes de las transacciones - Implementar manejo de errores adecuado - Usar l√≠mites
    y precios de gas apropiados - Probar exhaustivamente
  </Card>
</CardGroup>
