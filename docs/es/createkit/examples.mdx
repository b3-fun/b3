---
title: Ejemplos
description: Ejemplos de implementaci√≥n completos para casos de uso comunes de CreateKit
lang: es
originalPath: createkit/examples.mdx
---

## Resumen

Esta p√°gina proporciona ejemplos completos y reales de implementaci√≥n de CreateKit en varios escenarios. Cada ejemplo incluye c√≥digo completo, manejo de errores y mejores pr√°cticas.

## Colecci√≥n B√°sica de NFT

Una colecci√≥n de arte simple con acu√±aci√≥n gratuita:

```typescript title="Colecci√≥n de Arte B√°sica"
import { CollectionManager, BaseMintStorage, b3Testnet } from "@b3dotfun/basemint";
import { createPublicClient, createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";

async function createBasicArtCollection() {
  // Configurar clientes
  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
  const publicClient = createPublicClient({
    chain: b3Testnet,
    transport: http(),
  });
  const walletClient = createWalletClient({
    chain: b3Testnet,
    transport: http(),
    account,
  });

  // Inicializar servicios
  const collectionManager = new CollectionManager(publicClient);
  const storage = new BaseMintStorage({ baseUrl: "https://api.basemint.fun" });

  // Definir colecci√≥n
  const artCollection = {
    name: "Galer√≠a de Arte Digital",
    symbol: "DAG",
    creator: account.address,
    gameOwner: account.address,
    description: "Una colecci√≥n curada de obras de arte digitales",
    image: "https://example.com/art-collection.png",
    maxSupply: 1000n,
    mintPrice: 0n, // Acu√±aci√≥n gratuita
    maxPerWallet: 5n,
    tokenStandard: "ERC721" as const,
    chainId: 1993,
  };

  try {
    console.log("üé® Creando colecci√≥n de arte...");

    // Generar firma del creador
    const creatorSignature = await collectionManager.generateCreatorSignature(walletClient, artCollection);

    // Predecir direcci√≥n
    const predictedAddress = collectionManager.predictCollectionAddress(artCollection, creatorSignature);
    console.log(`üìç Direcci√≥n de la colecci√≥n: ${predictedAddress}`);

    // Enviar a almacenamiento
    await storage.submitCollection(artCollection, creatorSignature);
    console.log("‚úÖ Metadatos de la colecci√≥n almacenados");

    // Desplegar y acu√±ar el primer NFT
    const deployerSignature = await collectionManager.generateDeployerSignature(walletClient, predictedAddress);

    const collection = collectionManager.createCollection(predictedAddress, "ERC721");
    const mintTx = await collection.mint(walletClient, 1n, undefined, 0n, [], creatorSignature, deployerSignature);

    console.log(`üéâ Colecci√≥n desplegada y primer NFT acu√±ado: ${mintTx}`);
    return { collection, predictedAddress, mintTx };
  } catch (error) {
    console.error("‚ùå Fall√≥ la creaci√≥n de la colecci√≥n de arte:", error);
    throw error;
  }
}

// Uso
createBasicArtCollection()
  .then(result => console.log("Colecci√≥n creada exitosamente:", result))
  .catch(error => console.error("Creaci√≥n fallida:", error));
```

## Colecci√≥n de Juegos con Lista Blanca

Una colecci√≥n de juegos con acceso de lista blanca por niveles:

<Accordion title="Ejemplo Completo de Colecci√≥n de Juegos">
```typescript
import { 
  CollectionManager, 
  WhitelistManager,
  BaseMintStorage,
  RewardTracker,
  b3Testnet 
} from '@b3dotfun/basemint'
import { createPublicClient, createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'

class GamingCollectionManager {
private publicClient: any
private walletClient: any
private collectionManager: CollectionManager
private storage: BaseMintStorage
private rewardTracker: RewardTracker

constructor(privateKey: string) {
const account = privateKeyToAccount(privateKey as `0x${string}`)

    this.publicClient = createPublicClient({
      chain: b3Testnet,
      transport: http()
    })

    this.walletClient = createWalletClient({
      chain: b3Testnet,
      transport: http(),
      account
    })

    this.collectionManager = new CollectionManager(this.publicClient)
    this.storage = new BaseMintStorage({ baseUrl: 'https://api.basemint.fun' })
    this.rewardTracker = new RewardTracker(this.publicClient)

}

async createGamingCollection() {
// Definir niveles de jugadores
const playerTiers = {
legendary: [
"0x1111111111111111111111111111111111111111",
"0x2222222222222222222222222222222222222222"
],
epic: [
"0x3333333333333333333333333333333333333333",
"0x4444444444444444444444444444444444444444",
"0x5555555555555555555555555555555555555555"
],
rare: [
"0x6666666666666666666666666666666666666666",
"0x7777777777777777777777777777777777777777",
"0x8888888888888888888888888888888888888888"
]
}

    // Crear lista blanca combinada
    const allPlayers = [
      ...playerTiers.legendary.map(address => ({ address })),
      ...playerTiers.epic.map(address => ({ address })),
      ...playerTiers.rare.map(address => ({ address }))
    ]

    const whitelist = new WhitelistManager(allPlayers)
    const merkleRoot = whitelist.getRoot()

    // Definir colecci√≥n
    const gamingCollection = {
      name: "√çtems de Juego Legendarios",
      symbol: "LGI",
      creator: this.walletClient.account.address,
      gameOwner: "0x9999999999999999999999999999999999999999", // Plataforma de juego
      description: "√çtems exclusivos de juego para los mejores jugadores",
      image: "https://example.com/gaming-collection.png",

      // Configuraci√≥n de lista blanca
      isWhitelistEnabled: true,
      whitelistMerkleRoot: merkleRoot,

      // Precios y l√≠mites
      maxSupply: 500n,
      mintPrice: parseEther("0.01"),
      maxPerWallet: 3n,

      // Tiempos - fase de lista blanca por 24 horas
      startTime: BigInt(Math.floor(Date.now() / 1000)),
      endTime: BigInt(Math.floor(Date.now() / 1000) + 86400 * 7),

      tokenStandard: "ERC1155" as const,
      chainId: 1993,

      // Metadatos espec√≠ficos del juego
      attributes: [
        { trait_type: "Categor√≠a", value: "Juego" },
        { trait_type: "Rareza", value: "Legendario" },
        { trait_type: "Juego", value: "RPG de Fantas√≠a" }
      ]
    }

    try {
      console.log("üéÆ Creando colecci√≥n de juegos...")

      // Generar firmas
      const creatorSignature = await this.collectionManager.generateCreatorSignature(
        this.walletClient,
        gamingCollection
      )

      const predictedAddress = this.collectionManager.predictCollectionAddress(
        gamingCollection,
        creatorSignature
      )

      // Enviar a almacenamiento con referente del juego
      await this.storage.submitCollection(
        gamingCollection,
        creatorSignature,
        "juego-rpg-de-fantas√≠a" // ID del referente
      )

      console.log(`‚úÖ Colecci√≥n de juegos almacenada en: ${predictedAddress}`)

      return {
        collection: gamingCollection,
        predictedAddress,
        whitelist,
        playerTiers
      }

    } catch (error) {
      console.error("‚ùå Creaci√≥n de colecci√≥n de juegos fallida:", error)
      throw error
    }

}

async mintForPlayer(
collectionAddress: string,
whitelist: WhitelistManager,
playerAddress: string,
quantity: bigint = 1n
) {
try {
// Verificar si la colecci√≥n est√° desplegada
const collection = this.collectionManager.createCollection(collectionAddress, "ERC1155")
const isDeployed = await collection.isDeployed()

      if (!isDeployed) {
        // Primera acu√±aci√≥n - desplegar colecci√≥n
        const deployerSignature = await this.collectionManager.generateDeployerSignature(
          this.walletClient,
          collectionAddress
        )

        // Obtener prueba de lista blanca
        const proof = whitelist.getProof(playerAddress)
        const mintPrice = parseEther("0.01") * quantity

        const tx = await collection.mint(
          this.walletClient,
          quantity,
          "https://example.com/espada-legendaria.json", // Metadatos espec√≠ficos del √≠tem
          mintPrice,
          proof,
          undefined, // firma del creador necesaria para el despliegue
          deployerSignature
        )

        console.log(`üöÄ Colecci√≥n desplegada y √≠tem acu√±ado: ${tx}`)
        return tx

      } else {
        // Acu√±aci√≥n regular
        const proof = whitelist.getProof(playerAddress)
        const mintPrice = parseEther("0.01") * quantity

        const tx = await collection.mint(
          this.walletClient,
          quantity,
          "https://example.com/espada-legendaria.json",
          mintPrice,
          proof
        )

        console.log(`‚öîÔ∏è √çtem de juego acu√±ado: ${tx}`)
        return tx
      }

    } catch (error: any) {
      if (error.message.includes('Prueba de merkle inv√°lida')) {
        console.error(`‚ùå Jugador ${playerAddress} no est√° en la lista blanca`)
      } else {
        console.error("‚ùå Acu√±aci√≥n fallida:", error)
      }
      throw error
    }

}

async getPlayerRewards(collectionAddress: string, playerAddress: string) {
const escrowAddress = this.collectionManager.getEscrowAddress()

    // Verificar si el jugador fue el primer acu√±ador
    const firstMinterRewards = await this.rewardTracker.getRecipientRewards(
      escrowAddress,
      collectionAddress,
      "FIRST_MINTER",
      playerAddress
    )

    // Obtener estad√≠sticas de la colecci√≥n
    const collectionRewards = await this.rewardTracker.getCollectionRewards(
      escrowAddress,
      collectionAddress
    )

    return {
      firstMinterRewards: firstMinterRewards.toString(),
      collectionTotalRewards: collectionRewards.totalRewards.toString(),
      collectionMints: collectionRewards.totalMints.toString()
    }

}
}

// Ejemplo de uso
async function main() {
const gameManager = new GamingCollectionManager(process.env.PRIVATE_KEY!)

// Crear colecci√≥n
const { predictedAddress, whitelist, playerTiers } = await gameManager.createGamingCollection()

// Simular acu√±aci√≥n de jugador legendario
const legendaryPlayer = playerTiers.legendary[0]
await gameManager.mintForPlayer(predictedAddress, whitelist, legendaryPlayer, 2n)

// Verificar recompensas
const rewards = await gameManager.getPlayerRewards(predictedAddress, legendaryPlayer)
console.log("Recompensas del jugador:", rewards)
}

main().catch(console.error)

````
</Accordion>

## Plataforma Multi-Colecci√≥n

Una plataforma que gestiona m√∫ltiples colecciones:

<Accordion title="Ejemplo de Plataforma Multi-Colecci√≥n">
```typescript
import {
  CollectionManager,
  BaseMintStorage,
  RewardTracker,
  b3Testnet
} from '@b3dotfun/basemint'

class NFTPlatform {
  private collectionManager: CollectionManager
  private storage: BaseMintStorage
  private rewardTracker: RewardTracker
  private platformId: string

  constructor(
    publicClient: any,
    platformId: string
  ) {
    this.collectionManager = new CollectionManager(publicClient)
    this.storage = new BaseMintStorage({ baseUrl: 'https://api.basemint.fun' })
    this.rewardTracker = new RewardTracker(publicClient)
    this.platformId = platformId
  }

  async registerPlatform() {
    try {
      await this.storage.registerReferrer(this.platformId, {
        name: "Mi Plataforma NFT",
        website: "https://mynftplatform.com",
        description: "Una plataforma para crear y gestionar colecciones NFT"
      })
      console.log(`‚úÖ Plataforma registrada: ${this.platformId}`)
    } catch (error: any) {
      if (error.message.includes('ya existe')) {
        console.log(`‚ÑπÔ∏è Plataforma ${this.platformId} ya registrada`)
      } else {
        throw error
      }
    }
  }

  async createCollection(
    creatorWalletClient: any,
    collectionData: {
      name: string
      symbol: string
      description: string
      image: string
      maxSupply: bigint
      mintPrice: bigint
      category: string
    }
  ) {
    const collection = {
      ...collectionData,
      creator: creatorWalletClient.account.address,
      gameOwner: creatorWalletClient.account.address, // La plataforma podr√≠a ser el propietario del juego
      tokenStandard: "ERC721" as const,
      chainId: 1993,
      attributes: [
        { trait_type: "Plataforma", value: "Mi Plataforma NFT" },
        { trait_type: "Categor√≠a", value: collectionData.category }
      ]
    }

    // Generar firma y almacenar
    const creatorSignature = await this.collectionManager.generateCreatorSignature(
      creatorWalletClient,
      collection
    )

    const predictedAddress = this.collectionManager.predictCollectionAddress(
      collection,
      creatorSignature
    )

    await this.storage.submitCollection(
      collection,
      creatorSignature,
      this.platformId
    )

    return {
      collection,
      predictedAddress,
      creatorSignature
    }
  }

  async deployCollection(
    deployerWalletClient: any,
    collectionAddress: string,
    creatorSignature: string
  ) {
    const deployerSignature = await this.collectionManager.generateDeployerSignature(
      deployerWalletClient,
      collectionAddress
    )

    const collection = this.collectionManager.createCollection(collectionAddress, "ERC721")

    const tx = await collection.mint(
      deployerWalletClient,
      1n,
      undefined,
      0n, // El desplegador obtiene la primera acu√±aci√≥n gratis
      [],
      creatorSignature,
      deployerSignature
    )

    return tx
  }

  async getPlatformStats() {
    const collections = await this.storage.queryCollections({
      referrer: this.platformId
    })

    const stats = {
      totalCollections: collections.total,
      deployed: 0,
      undeployed: 0,
      totalVolume: 0n,
      totalRewards: 0n
    }

    const escrowAddress = this.collectionManager.getEscrowAddress()

    for (const collection of collections.collections) {
      if (collection.isDeployed) {
        stats.deployed++

        // Obtener recompensas de la colecci√≥n
        const rewards = await this.rewardTracker.getCollectionRewards(
          escrowAddress,
          collection.address
        )
        stats.totalRewards += rewards.totalRewards
      } else {
        stats.undeployed++
      }
    }

    return {
      ...stats,
      collections: collections.collections
    }
  }

  async getCreatorDashboard(creatorAddress: string) {
    const collections = await this.storage.queryCollections({
      creator: creatorAddress,
      referrer: this.platformId
    })

    const escrowAddress = this.collectionManager.getEscrowAddress()
    let totalCreatorRewards = 0n

    const collectionStats = await Promise.all(
      collections.collections.map(async (collection) => {
        if (collection.isDeployed) {
          const rewards = await this.rewardTracker.getRecipientRewards(
            escrowAddress,
            collection.address,
            "CREATOR",
            creatorAddress
          )
          totalCreatorRewards += rewards

          return {
            ...collection,
            creatorRewards: rewards.toString()
          }
        }
        return {
          ...collection,
          creatorRewards: "0"
        }
      })
    )

    return {
      totalCollections: collections.total,
      totalCreatorRewards: totalCreatorRewards.toString(),
      collections: collectionStats
    }
  }
}

// Uso
async function runPlatform() {
  const publicClient = createPublicClient({
    chain: b3Testnet,
    transport: http()
  })

  const platform = new NFTPlatform(publicClient, "mi-plataforma-nft")

  // Registrar plataforma
  await platform.registerPlatform()

  // Creador crea colecci√≥n
  const creatorAccount = privateKeyToAccount(process.env.CREATOR_PRIVATE_KEY as `0x${string}`)
  const creatorWalletClient = createWalletClient({
    chain: b3Testnet,
    transport: http(),
    account: creatorAccount
  })

  const { predictedAddress, creatorSignature } = await platform.createCollection(
    creatorWalletClient,
    {
      name: "Colecci√≥n de Arte Asombroso",
      symbol: "AAC",
      description: "Obras de arte digitales incre√≠bles",
      image: "https://example.com/awesome-art.png",
      maxSupply: 1000n,
      mintPrice: parseEther("0.005"),
      category: "Arte"
    }
  )

  // Desplegar colecci√≥n
  const deployerAccount = privateKeyToAccount(process.env.DEPLOYER_PRIVATE_KEY as `0x${string}`)
  const deployerWalletClient = createWalletClient({
    chain: b3Testnet,
    transport: http(),
    account: deployerAccount
  })

  const deployTx = await platform.deployCollection(
    deployerWalletClient,
    predictedAddress,
    creatorSignature
  )

  console.log(`üöÄ Colecci√≥n desplegada: ${deployTx}`)

  // Obtener estad√≠sticas de la plataforma
  const stats = await platform.getPlatformStats()
  console.log("Estad√≠sticas de la plataforma:", stats)

  // Obtener panel de control del creador
  const dashboard = await platform.getCreatorDashboard(creatorAccount.address)
  console.log("Panel de control del creador:", dashboard)
}

runPlatform().catch(console.error)
````

</Accordion>
