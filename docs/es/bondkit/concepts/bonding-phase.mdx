---
title: Fase de Vinculaci√≥n
description: 'C√≥mo funciona la compra y venta durante la fase de enlace, tarifas y umbrales.'
lang: es
originalPath: bondkit/concepts/bonding-phase.mdx
---
## ¬øQu√© es la Fase de Vinculaci√≥n?

La fase de vinculaci√≥n es el per√≠odo inicial de comercio donde los tokens se compran y venden directamente desde un contrato inteligente utilizando una curva de precios algor√≠tmica. Pi√©nsalo como una preventa descentralizada con creaci√≥n de mercado autom√°tica.

```mermaid
stateDiagram-v2
    [*] --> Created: Token Desplegado
    Created --> Bonding: Autom√°tico
    Bonding --> Bonding: Compras/Ventas
    Bonding --> MigrationReady: Objetivo Alcanzado
    MigrationReady --> DEX: migrateToDex()
    DEX --> [*]: Completamente Descentralizado
    
    note right of Bonding
        Comercio directo con contrato
        Precios algor√≠tmicos
        5% de comisi√≥n por comercio
        Acumula liquidez
    end note
    
    note right of DEX
        Comercio en Uniswap v4
        Precio impulsado por el mercado
        Comisiones LP est√°ndar
        Sin control administrativo
    end note
```

## C√≥mo Funciona la Vinculaci√≥n

### El Mecanismo de la Curva de Vinculaci√≥n

Durante la vinculaci√≥n, el contrato act√∫a como el √∫nico creador de mercado:

1. **Sin Libro de √ìrdenes**: Precios determinados algor√≠tmicamente
2. **Liquidez Instant√°nea**: Siempre se puede comprar o vender
3. **Independencia de Trayectoria**: El precio depende solo de la oferta, no de la historia
4. **Precios Autom√°ticos**: No se necesita establecer precios manualmente

## Operaciones de Comercio

### Comprando Tokens

<Tabs>
  <Tab title="C√≥mo Funciona">
    **Flujo de Proceso:**
    1. El usuario env√≠a el token de comercio (B3/ETH) al contrato
    2. El contrato calcula los tokens basados en la curva
    3. Se deduce una comisi√≥n del 5% y se env√≠a al destinatario
    4. Se acu√±an los tokens y se env√≠an al comprador
    5. Se actualiza el estado de la curva
    
    **Ejemplo de C√≥digo:**
    ```typescript
    // Obtener una cotizaci√≥n primero
    const quote = await token.getAmountOfTokensToBuy(
      parseEther("100") // 100 tokens de comercio
    );
    console.log(`Recibir√°: ${formatEther(quote)} tokens`);
    
    // Ejecutar compra con protecci√≥n contra deslizamiento  
    const minTokens = quote * 0.95n; // 5% de deslizamiento
    await token.buy(parseEther("100"), minTokens);
    ```
  </Tab>
  
  <Tab title="Par√°metros">
    | Par√°metro | Tipo | Descripci√≥n |
    |-----------|------|-------------|
    | `minTokensOut` | uint256 | Tokens m√≠nimos a recibir (protecci√≥n contra deslizamiento) |
    | `tradingTokenAmount` | string/uint256 | Cantidad de token de comercio a gastar |
    
    **Notas Importantes:**
    - Establecer `minTokensOut` para protegerse contra el front-running
    - Usar 0 para `minTokensOut` solo en per√≠odos de baja actividad
    - La transacci√≥n se revierte si el deslizamiento supera la tolerancia
  </Tab>
  
  <Tab title="Casos L√≠mite">
    **Desbordamiento del Objetivo:**
    - Si la compra excediera el objetivo, el exceso se reembolsa
    - Ejemplo: El objetivo es 10 tokens de comercio, se han recaudado 9.5 tokens
    - El usuario env√≠a 1 token ‚Üí Se usan 0.5 tokens, se reembolsan 0.5 tokens
    
    **Gas Insuficiente:**
    - L√≠mite de gas recomendado: 200,000
    - C√°lculos complejos pueden requerir m√°s
    
    **Cantidad Cero:**
    - Las transacciones con 0 tokens de comercio se revertir√°n
  </Tab>
</Tabs>

### Vendiendo Tokens

<Tabs>
  <Tab title="C√≥mo Funciona">
    **Flujo de Proceso:**
    1. El usuario aprueba el gasto de tokens
    2. El usuario llama a vender con la cantidad de tokens
    3. El contrato calcula la cantidad de token de comercio basado en la curva
    4. Se deduce una comisi√≥n del 5% de los ingresos
    5. El token de comercio se env√≠a al vendedor, los tokens se queman
    6. Se actualiza el estado de la curva (el precio disminuye)
    
    **Ejemplo de C√≥digo:**
    ```typescript
    // Verificar saldo y obtener cotizaci√≥n
    const balance = await token.balanceOf(userAddress);
    const sellAmount = balance / 2n; // Vender la mitad
    
    const quote = await token.getAmountOfTradingTokensToSell(
      sellAmount
    );
    console.log(`Recibir√°: ${formatEther(quote)} tokens de comercio`);
    
    // Ejecutar venta con protecci√≥n contra deslizamiento
    const minTradingTokenOut = quote * 0.95n; // 5% de deslizamiento
    await token.sell(sellAmount, minTradingTokenOut);
    ```
  </Tab>
  
  <Tab title="Par√°metros">
    | Par√°metro | Tipo | Descripci√≥n |
    |-----------|------|-------------|
    | `tokenAmount` | uint256 | Cantidad de tokens a vender |
    | `minTradingTokenOut` | uint256 | Token de comercio m√≠nimo a recibir (protecci√≥n contra deslizamiento) |
    
    **Notas Importantes:**
    - Requiere aprobaci√≥n de tokens antes de vender
    - El impacto en el precio puede ser significativo para ventas grandes
    - No se pueden vender m√°s que el suministro circulante
  </Tab>
  
  <Tab title="Impacto del Precio">
    **Entendiendo el Impacto de la Venta:**
    
    Vender reduce la cantidad recaudada de la curva, causando que el precio baje:
    
    | Tama√±o de Venta | Impacto del Precio | Recuperaci√≥n Necesaria |
    |-----------|--------------|-----------------|
    | 1% del suministro | ~1-2% | Peque√±a |
    | 5% del suministro | ~5-10% | Moderada |
    | 10% del suministro | ~15-25% | Significativa |
    | 20% del suministro | ~30-50% | Mayor |
    
    *El impacto real depende del factor de agresividad*
  </Tab>
</Tabs>

## Estructura de Comisiones

### C√≥mo Funcionan las Comisiones

```mermaid
graph LR
    A[Comercio de Usuario] -->|100%| B[Contrato]
    B -->|95%| C[Curva/Usuario]
    B -->|5%| D[Destinatario de la Comisi√≥n]
    
    style A fill:#e1f5fe
    style D fill:#c8e6c9
```

<AccordionGroup>
  <Accordion title="Comisiones de Compra">
    **En una compra de 1 token de comercio:**
    - 0.95 tokens de comercio van a la curva de vinculaci√≥n
    - 0.05 tokens de comercio van al destinatario de la comisi√≥n
    - Tokens calculados sobre el valor de 0.95 token de comercio
    
    **Ejemplo:**
    ```typescript
    // El usuario env√≠a 1 token de comercio
    // Comisi√≥n: 0.05 token de comercio
    // La curva recibe: 0.95 token de comercio
    // Tokens acu√±ados basados en 0.95 token de comercio
    ```
  </Accordion>
  
  <Accordion title="Comisiones de Venta">
    **Al vender por valor de 1 token de comercio:**
    - El usuario recibe 0.95 tokens de comercio
    - 0.05 tokens de comercio van al destinatario de la comisi√≥n
    - La curva se reduce por el total de 1 token de comercio
    
    **Ejemplo:**
    ```typescript
    // Tokens valorados en 1 token de comercio en la curva
    // Comisi√≥n: 0.05 token de comercio
    // El usuario recibe: 0.95 tokens de comercio
    // La curva baja por 1 token de comercio
    ```
  </Accordion>
  
  <Accordion title="Distribuci√≥n de Comisiones">
    **A d√≥nde van las comisiones:**
    - 100% a la direcci√≥n de `feeRecipient` designada
    - Puede ser tesorer√≠a del proyecto, desarrollador, o DAO
    - Establecido al crear el token, no se puede cambiar
    
    **Reclamando comisiones:**
    - Autom√°tico - no se necesita reclamar
    - Enviado directamente en cada comercio
    - No se acumula en el contrato
  </Accordion>
</AccordionGroup>

### Econom√≠a de las Comisiones

| Volumen Diario | Ingresos por Comisiones | Ingresos Mensuales |
|-------------|------------|----------------|
| 10 tokens de comercio | 0.5 tokens de comercio | ~15 tokens de comercio |
| 50 tokens de comercio | 2.5 tokens de comercio | ~75 tokens de comercio |
| 100 tokens de comercio | 5 tokens de comercio | ~150 tokens de comercio |
| 500 tokens de comercio | 25 tokens de comercio | ~750 tokens de comercio |

## Mec√°nica del Objetivo

### Entendiendo el Objetivo

El objetivo es la cantidad de token de comercio que debe acumularse antes de la migraci√≥n:

<Info>
  **Prop√≥sito del Objetivo:**
  - Asegura suficiente liquidez para Uniswap v4
  - Crea un objetivo claro para la comunidad
  - Previene la migraci√≥n prematura
  - Construye momento durante la vinculaci√≥n
</Info>

### Acerc√°ndose al Objetivo

```typescript
// Monitorear el progreso hacia el objetivo
async function trackProgress(token: BondkitToken) {
  const progress = await token.getBondingProgress();
  
  if (progress.progress < 0.5) {
    console.log("üå± Etapa inicial - mejores precios disponibles");
  } else if (progress.progress < 0.8) {
    console.log("üöÄ Construyendo momento - considera comprar");
  } else if (progress.progress < 1.0) {
    console.log("üî• Casi all√≠ - migraci√≥n inminente");
  } else {
    console.log("‚úÖ Objetivo alcanzado - listo para migrar!");
  }
  
  la cantidadRestante = progress.threshold - progress.raised;
  console.log(`Necesita ${formatEther(cantidadRestante)} m√°s token de comercio`);
}
```

### Manejo de Desbordamiento

Cuando una compra exceder√≠a el objetivo:

1. **Relleno Parcial**: Solo se acepta la cantidad necesaria
2. **Reembolso Autom√°tico**: El exceso se devuelve en la misma transacci√≥n
3. **Finalizaci√≥n Justa**: Nadie puede pagar de m√°s al final

**Escenario de Ejemplo:**
```
Objetivo: 100 tokens de comercio
Actual: 99.5 tokens de comercio
El usuario env√≠a: 2 tokens de comercio

Resultado:
- 0.5 tokens de comercio aceptados (alcanza exactamente 100)
- 1.5 tokens de comercio reembolsados
- El usuario obtiene tokens por 0.5 tokens de comercio
- Migraci√≥n ahora disponible
```

## Eventos y Monitoreo

### Eventos del Contrato

<Tabs>
  <Tab title="Evento de Compra">
    ```solidity
    event BondingCurveBuy(
        address indexed payer,
        address indexed recipient,
        uint256 tradingTokenIn,
        uint256 tokensOut,
        uint256 fee,
        uint256 totalRaisedBonding
    );
    ```
    
    **Escuchando en SDK:**
    ```typescript
    token.onBuy((event) => {
      console.log({
        comprador: event.payer,
        ethGastado: formatEther(event.tradingTokenIn),
        tokensRecibidos: formatEther(event.tokensOut),
        comisi√≥nPagada: formatEther(event.fee),
        totalRecaudado: formatEther(event.totalRaisedBonding)
      });
    });
    ```
  </Tab>
  
  <Tab title="Evento de Venta">
    ```solidity
    event BondingCurveSell(
        address indexed seller,
        uint256 tokensIn,
        uint256 tradingTokenOut,
        uint256 fee,
        uint256 totalRaisedBonding
    );
    ```
    
    **Escuchando en SDK:**
    ```typescript
    token.onSell((event) => {
      console.log({
        vendedor: event.seller,
        tokensVendidos: formatEther(event.tokensIn),
        ethRecibido: formatEther(event.tradingTokenOut),
        comisi√≥nPagada: formatEther(event.fee),
        totalRecaudado: formatEther(event.totalRaisedBonding)
      });
    });
    ```
  </Tab>
</Tabs>

### Monitoreo en Tiempo Real

```typescript
// Configuraci√≥n completa de monitoreo
class BondingMonitor {
  constructor(private token: BondkitToken) {}
  
  async start() {
    // Estado inicial
    const progress = await this.token.getBondingProgress();
    console.log(`Comenzando en ${(progress.progress * 100).toFixed(2)}%`);
    
    // Monitorear compras
    this.token.onBuy(async (event) => {
      const newProgress = await this.token.getBondingProgress();
      console.log(`COMPRA: ${formatEther(event.tokensOut)} tokens`);
      console.log(`Progreso: ${(newProgress.progress * 100).toFixed(2)}%`);
      
      if (newProgress.progress >= 1.0) {
        console.log("üéÜ ¬°OBJETIVO ALCANZADO! Migraci√≥n disponible.");
      }
    });
    
    // Monitorear ventas
    this.token.onSell(async (event) => {
      const newProgress = await this.token.getBondingProgress();
      console.log(`VENTA: ${formatEther(event.tokensIn)} tokens`);
      console.log(`Progreso: ${(newProgress.progress * 100).toFixed(2)}%`);
    });
  }
}

// Uso
const monitor = new BondingMonitor(token);
await monitor.start();
```

## Estrategias de la Fase de Vinculaci√≥n

### Para Creadores de Tokens

<CardGroup cols={2}>
  <Card title="Construir Momento" icon="chart-line">
    - Comenzar con menor agresividad (30-50)
    - Establecer objetivos alcanzables
    - Involucrar a la comunidad temprano
    - Proporcionar una hoja de ruta clara
  </Card>
  
  <Card title="Maximizar el √âxito" icon="trophy">
    - Sembrar liquidez inicial t√∫ mismo
    - Crear incentivos de compra
    - Temporizar anuncios adecuadamente
    - Planificar para despu√©s de la migraci√≥n
  </Card>
</CardGroup>

### Para Comerciantes

<CardGroup cols={2}>
  <Card title="Estrategia de Entrada" icon="door-open">
    - Comprar temprano para mejores precios
    - Usar DCA para grandes cantidades
    - Monitorear el factor de agresividad
    - Verificar el progreso del objetivo
  </Card>
  
  <Card title="Gesti√≥n del Riesgo" icon="shield">
    - Siempre usar protecci√≥n contra deslizamiento
    - Entender el impacto en el precio
    - No dejarse llevar por FOMO cerca del objetivo
    - Planificar estrategia de salida
  </Card>
</CardGroup>

## Transici√≥n Post-Vinculaci√≥n

<Warning>
  **Cr√≠tico: Despu√©s de la Migraci√≥n**
  
  Una vez se llama a `migrateToDex()`:
  - ‚ùå Comercio en la curva de vinculaci√≥n permanentemente deshabilitado
  - ‚ùå No m√°s funciones de buy() o sell()
  - ‚úÖ Todo el comercio se traslada a Uniswap v4
  - ‚úÖ Se aplican mec√°nicas AMM est√°ndar
  - ‚úÖ Cualquiera puede proporcionar liquidez
  - ‚úÖ Comercio completamente descentralizado
</Warning>

## Pr√≥ximos Pasos

<CardGroup cols={3}>
  <Card title="Gu√≠a de Precios" icon="tags" href="/bondkit/concepts/pricing">
    Entender la mec√°nica de precios
  </Card>
  <Card title="Establecimiento de Objetivos" icon="bullseye" href="/bondkit/concepts/targets">
    Elegir el objetivo correcto
  </Card>
  <Card title="Ciclo de Vida del Token" icon="rocket" href="/bondkit/guides/token-lifecycle">
    Aprender sobre la transici√≥n a DEX
  </Card>
</CardGroup>
